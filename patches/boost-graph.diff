diff --git a/CMakeLists.txt b/CMakeLists.txt
index 0e294eb5..bfd287bd 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -42,39 +42,40 @@ target_link_libraries(boost_graph
     Boost::parameter
     Boost::preprocessor
     Boost::property_map
     Boost::property_tree
     Boost::random
     Boost::range
     Boost::serialization
     Boost::smart_ptr
     Boost::spirit
     Boost::static_assert
     Boost::throw_exception
     Boost::tti
     Boost::tuple
     Boost::type_traits
     Boost::typeof
     Boost::unordered
     Boost::utility
     Boost::xpressive
   PRIVATE
     Boost::regex
+    Boost::interprocess
 )
 
 target_compile_definitions(boost_graph
   PUBLIC BOOST_GRAPH_NO_LIB
   # Source files already define BOOST_GRAPH_SOURCE
   # PRIVATE BOOST_GRAPH_SOURCE
 )
 
 if(BUILD_SHARED_LIBS)
   target_compile_definitions(boost_graph PUBLIC BOOST_GRAPH_DYN_LINK)
 else()
   target_compile_definitions(boost_graph PUBLIC BOOST_GRAPH_STATIC_LINK)
 endif()
 
 if(BUILD_TESTING AND EXISTS "${CMAKE_CURRENT_SOURCE_DIR}/test/CMakeLists.txt")
 
   add_subdirectory(test)
 
 endif()
diff --git a/include/boost/graph/adj_list_serialize.hpp b/include/boost/graph/adj_list_serialize.hpp
index 85f7e2ed..9d2ceda7 100644
--- a/include/boost/graph/adj_list_serialize.hpp
+++ b/include/boost/graph/adj_list_serialize.hpp
@@ -53,78 +53,82 @@ namespace serialization
 
         // assign indices to vertices
         std::map< Vertex, int > indices;
         int num = 0;
         BGL_FORALL_VERTICES_T(v, graph, Graph)
         {
             indices[v] = num++;
             ar << serialization::make_nvp(
                 "vertex_property", get(vertex_all_t(), graph, v));
         }
 
         // write edges
         BGL_FORALL_EDGES_T(e, graph, Graph)
         {
             ar << serialization::make_nvp("u", indices[source(e, graph)]);
             ar << serialization::make_nvp("v", indices[target(e, graph)]);
             ar << serialization::make_nvp(
                 "edge_property", get(edge_all_t(), graph, e));
         }
 
+#if 0
         ar << serialization::make_nvp(
             "graph_property", get_property(graph, graph_all_t()));
+#endif
     }
 
     template < class Archive, class OEL, class VL, class D, class VP, class EP,
         class GP, class EL >
     inline void load(
         Archive& ar, boost::adjacency_list< OEL, VL, D, VP, EP, GP, EL >& graph,
         const unsigned int /* file_version */
     )
     {
         typedef adjacency_list< OEL, VL, D, VP, EP, GP, EL > Graph;
         typedef typename graph_traits< Graph >::vertex_descriptor Vertex;
         typedef typename graph_traits< Graph >::edge_descriptor Edge;
 
         unsigned int V;
         ar >> BOOST_SERIALIZATION_NVP(V);
         unsigned int E;
         ar >> BOOST_SERIALIZATION_NVP(E);
 
         std::vector< Vertex > verts(V);
         int i = 0;
         while (V-- > 0)
         {
-            Vertex v = add_vertex(graph);
+            Vertex v = add_vertex(graph, graph.m_vertices.get_allocator());
             verts[i++] = v;
             ar >> serialization::make_nvp(
                 "vertex_property", get(vertex_all_t(), graph, v));
         }
         while (E-- > 0)
         {
             int u;
             int v;
             ar >> BOOST_SERIALIZATION_NVP(u);
             ar >> BOOST_SERIALIZATION_NVP(v);
             Edge e;
             bool inserted;
             boost::tie(e, inserted) = add_edge(verts[u], verts[v], graph);
             ar >> serialization::make_nvp(
                 "edge_property", get(edge_all_t(), graph, e));
         }
+#if 0
         ar >> serialization::make_nvp(
             "graph_property", get_property(graph, graph_all_t()));
+#endif
     }
 
     template < class Archive, class OEL, class VL, class D, class VP, class EP,
         class GP, class EL >
     inline void serialize(Archive& ar,
         boost::adjacency_list< OEL, VL, D, VP, EP, GP, EL >& graph,
         const unsigned int file_version)
     {
         boost::serialization::split_free(ar, graph, file_version);
     }
 
 } // serialization
 } // boost
 
 #endif // BOOST_GRAPH_ADJ_LIST_SERIALIZE_HPP
diff --git a/include/boost/graph/adjacency_list.hpp b/include/boost/graph/adjacency_list.hpp
index e5050b5b..a37142aa 100644
--- a/include/boost/graph/adjacency_list.hpp
+++ b/include/boost/graph/adjacency_list.hpp
@@ -18,153 +18,216 @@
 #include <set>
 
 #include <boost/unordered_set.hpp>
 
 #include <boost/scoped_ptr.hpp>
 
 #include <boost/graph/graph_traits.hpp>
 #include <boost/graph/graph_mutability_traits.hpp>
 #include <boost/graph/graph_selectors.hpp>
 #include <boost/property_map/property_map.hpp>
 #include <boost/mpl/if.hpp>
 #include <boost/mpl/and.hpp>
 #include <boost/mpl/not.hpp>
 #include <boost/mpl/bool.hpp>
 #include <boost/graph/detail/edge.hpp>
 #include <boost/type_traits/is_same.hpp>
 #include <boost/detail/workaround.hpp>
 #include <boost/graph/properties.hpp>
 #include <boost/graph/named_graph.hpp>
 
+#include <boost/interprocess/allocators/allocator.hpp>
+#include <boost/interprocess/managed_shared_memory.hpp>
+#include <boost/interprocess/containers/vector.hpp>
+#include <boost/interprocess/containers/deque.hpp>
+#include <boost/interprocess/containers/list.hpp>
+#include <boost/interprocess/containers/set.hpp>
+
 namespace boost
 {
 
 //===========================================================================
 // Selectors for the VertexList and EdgeList template parameters of
 // adjacency_list, and the container_gen traits class which is used
 // to map the selectors to the container type used to implement the
 // graph.
 
 struct vecS
 {
 };
+struct vecS_ip
+{
+};
+struct dequeS_ip
+{
+};
 struct listS
 {
 };
+struct listS_ip
+{
+};
 struct setS
 {
 };
+struct setS_ip
+{
+};
 struct mapS
 {
 };
 struct multisetS
 {
 };
 struct multimapS
 {
 };
 struct hash_setS
 {
 };
 struct hash_mapS
 {
 };
 struct hash_multisetS
 {
 };
 struct hash_multimapS
 {
 };
 
 template < class Selector, class ValueType > struct container_gen
 {
 };
 
 template < class ValueType > struct container_gen< listS, ValueType >
 {
     typedef std::list< ValueType > type;
 };
 
+template < class ValueType > struct container_gen< listS_ip, ValueType >
+{
+    typedef interprocess::allocator<ValueType, interprocess::managed_shared_memory::segment_manager> _Allocator;
+    typedef interprocess::list< ValueType, _Allocator > type;
+};
+
 template < class ValueType > struct container_gen< vecS, ValueType >
 {
     typedef std::vector< ValueType > type;
 };
 
+template < class ValueType > struct container_gen< vecS_ip, ValueType >
+{
+    typedef interprocess::allocator<ValueType, interprocess::managed_shared_memory::segment_manager> _Allocator;
+    typedef interprocess::vector< ValueType, _Allocator > type;
+};
+
+template < class ValueType > struct container_gen< dequeS_ip, ValueType >
+{
+    typedef interprocess::allocator<ValueType, interprocess::managed_shared_memory::segment_manager> _Allocator;
+    typedef interprocess::deque< ValueType, _Allocator > type;
+};
+
 template < class ValueType > struct container_gen< mapS, ValueType >
 {
     typedef std::set< ValueType > type;
 };
 
 template < class ValueType > struct container_gen< setS, ValueType >
 {
     typedef std::set< ValueType > type;
 };
 
+template < class ValueType > struct container_gen< setS_ip, ValueType >
+{
+    typedef interprocess::allocator<ValueType, interprocess::managed_shared_memory::segment_manager> _Allocator;
+    typedef interprocess::set< ValueType, std::less<ValueType>, _Allocator > type;
+};
+
 template < class ValueType > struct container_gen< multisetS, ValueType >
 {
     typedef std::multiset< ValueType > type;
 };
 
 template < class ValueType > struct container_gen< multimapS, ValueType >
 {
     typedef std::multiset< ValueType > type;
 };
 
 template < class ValueType > struct container_gen< hash_setS, ValueType >
 {
     typedef boost::unordered_set< ValueType > type;
 };
 
 template < class ValueType > struct container_gen< hash_mapS, ValueType >
 {
     typedef boost::unordered_set< ValueType > type;
 };
 
 template < class ValueType > struct container_gen< hash_multisetS, ValueType >
 {
     typedef boost::unordered_multiset< ValueType > type;
 };
 
 template < class ValueType > struct container_gen< hash_multimapS, ValueType >
 {
     typedef boost::unordered_multiset< ValueType > type;
 };
 
 template < class StorageSelector > struct parallel_edge_traits
 {
 };
 
 template <> struct parallel_edge_traits< vecS >
 {
     typedef allow_parallel_edge_tag type;
 };
 
+template <> struct parallel_edge_traits< vecS_ip >
+{
+    typedef allow_parallel_edge_tag type;
+};
+
+template <> struct parallel_edge_traits< dequeS_ip >
+{
+    typedef allow_parallel_edge_tag type;
+};
+
 template <> struct parallel_edge_traits< listS >
 {
     typedef allow_parallel_edge_tag type;
 };
 
+template <> struct parallel_edge_traits< listS_ip >
+{
+    typedef allow_parallel_edge_tag type;
+};
+
 template <> struct parallel_edge_traits< setS >
 {
     typedef disallow_parallel_edge_tag type;
 };
 
+template <> struct parallel_edge_traits< setS_ip >
+{
+    typedef disallow_parallel_edge_tag type;
+};
+
 template <> struct parallel_edge_traits< multisetS >
 {
     typedef allow_parallel_edge_tag type;
 };
 
 template <> struct parallel_edge_traits< hash_setS >
 {
     typedef disallow_parallel_edge_tag type;
 };
 
 // mapS is obsolete, replaced with setS
 template <> struct parallel_edge_traits< mapS >
 {
     typedef disallow_parallel_edge_tag type;
 };
 
 template <> struct parallel_edge_traits< hash_mapS >
 {
     typedef disallow_parallel_edge_tag type;
 };
@@ -180,40 +243,56 @@ template <> struct parallel_edge_traits< hash_multimapS >
 };
 
 namespace detail
 {
     template < class Directed > struct is_random_access
     {
         enum
         {
             value = false
         };
         typedef mpl::false_ type;
     };
     template <> struct is_random_access< vecS >
     {
         enum
         {
             value = true
         };
         typedef mpl::true_ type;
     };
+    template <> struct is_random_access< vecS_ip >
+    {
+        enum
+        {
+            value = true
+        };
+        typedef mpl::true_ type;
+    };
+    template <> struct is_random_access< dequeS_ip >
+    {
+        enum
+        {
+            value = true
+        };
+        typedef mpl::true_ type;
+    };
 
 } // namespace detail
 
 template < typename Selector > struct is_distributed_selector : mpl::false_
 {
 };
 
 //===========================================================================
 // The adjacency_list_traits class, which provides a way to access
 // some of the associated types of an adjacency_list type without
 // having to first create the adjacency_list type. This is useful
 // when trying to create interior vertex or edge properties who's
 // value type is a vertex or edge descriptor.
 
 template < class OutEdgeListS = vecS, class VertexListS = vecS,
     class DirectedS = directedS, class EdgeListS = listS >
 struct adjacency_list_traits
 {
     typedef
         typename detail::is_random_access< VertexListS >::type is_rand_access;
@@ -295,59 +374,66 @@ public:
         edge_bundled;
 
 private:
     typedef adjacency_list self;
     typedef typename detail::adj_list_gen< self, VertexListS, OutEdgeListS,
         DirectedS, vertex_property_type, edge_property_type, GraphProperty,
         EdgeListS >::type Base;
 
 public:
     typedef typename Base::stored_vertex stored_vertex;
     typedef typename Base::vertices_size_type vertices_size_type;
     typedef typename Base::edges_size_type edges_size_type;
     typedef typename Base::degree_size_type degree_size_type;
     typedef typename Base::vertex_descriptor vertex_descriptor;
     typedef typename Base::edge_descriptor edge_descriptor;
     typedef OutEdgeListS out_edge_list_selector;
     typedef VertexListS vertex_list_selector;
     typedef DirectedS directed_selector;
     typedef EdgeListS edge_list_selector;
 
-    adjacency_list(const GraphProperty& p = GraphProperty())
-    : m_property(new graph_property_type(p))
+    template<class... _AllocArg>
+    adjacency_list(const GraphProperty& p = GraphProperty(), _AllocArg&&... AllocArg)
+    : Base(std::forward<_AllocArg>(AllocArg)...), m_property(new graph_property_type(p))
+    {
+    }
+
+    template<class... _AllocArg>
+    adjacency_list(const adjacency_list& x, _AllocArg&&... AllocArg)
+    : Base(std::forward<_AllocArg>(AllocArg)...), m_property(new graph_property_type(x.m_property ? *x.m_property : graph_property_type()))
     {
     }
 
     adjacency_list(const adjacency_list& x)
-    : Base(x), m_property(new graph_property_type(*x.m_property))
+    : Base(x, x.m_vertices.get_allocator()), m_property(new graph_property_type(x.m_property ? *x.m_property : graph_property_type()))
     {
     }
 
     adjacency_list& operator=(const adjacency_list& x)
     {
         // TBD: probably should give the strong guarantee
         if (&x != this)
         {
             Base::operator=(x);
 
             // Copy/swap the ptr since we can't just assign it...
-            property_ptr p(new graph_property_type(*x.m_property));
+            property_ptr p(new graph_property_type(x.m_property ? *x.m_property : graph_property_type()));
             m_property.swap(p);
         }
         return *this;
     }
 
     // Required by Mutable Graph
     adjacency_list(vertices_size_type num_vertices,
         const GraphProperty& p = GraphProperty())
     : Base(num_vertices), m_property(new graph_property_type(p))
     {
     }
 
     // Required by Iterator Constructible Graph
     template < class EdgeIterator >
     adjacency_list(EdgeIterator first, EdgeIterator last, vertices_size_type n,
         edges_size_type = 0, const GraphProperty& p = GraphProperty())
     : Base(n, first, last), m_property(new graph_property_type(p))
     {
     }
 
diff --git a/include/boost/graph/detail/adjacency_list.hpp b/include/boost/graph/detail/adjacency_list.hpp
index 7fb2c493..b37bc5bd 100644
--- a/include/boost/graph/detail/adjacency_list.hpp
+++ b/include/boost/graph/detail/adjacency_list.hpp
@@ -1790,41 +1790,42 @@ class adj_list_impl : public adj_list_helper< Config, Base >
     typedef typename Config::OutEdgeList OutEdgeList;
     typedef typename Config::InEdgeList InEdgeList;
     typedef typename Config::StoredVertexList StoredVertexList;
 
 public:
     typedef typename Config::stored_vertex stored_vertex;
     typedef typename Config::EdgeContainer EdgeContainer;
     typedef typename Config::vertex_descriptor vertex_descriptor;
     typedef typename Config::edge_descriptor edge_descriptor;
     typedef typename Config::vertex_iterator vertex_iterator;
     typedef typename Config::edge_iterator edge_iterator;
     typedef typename Config::edge_parallel_category edge_parallel_category;
     typedef typename Config::vertices_size_type vertices_size_type;
     typedef typename Config::edges_size_type edges_size_type;
     typedef typename Config::degree_size_type degree_size_type;
     typedef typename Config::edge_property_type edge_property_type;
     typedef adj_list_tag graph_tag;
 
     static vertex_descriptor null_vertex() { return 0; }
 
-    inline adj_list_impl() {}
+    template<class... _AllocArg>
+    inline adj_list_impl(_AllocArg&&... AllocArg) : m_edges(std::forward<_AllocArg>(AllocArg)...), m_vertices(std::forward<_AllocArg>(AllocArg)...) {}
 
     inline adj_list_impl(const adj_list_impl& x) { copy_impl(x); }
     inline adj_list_impl& operator=(const adj_list_impl& x)
     {
         this->clear();
         copy_impl(x);
         return *this;
     }
     inline void clear()
     {
         for (typename StoredVertexList::iterator i = m_vertices.begin();
              i != m_vertices.end(); ++i)
             delete (stored_vertex*)*i;
         m_vertices.clear();
         m_edges.clear();
     }
     inline adj_list_impl(vertices_size_type num_vertices)
     {
         for (vertices_size_type i = 0; i < num_vertices; ++i)
             add_vertex(static_cast< Derived& >(*this));
@@ -1900,47 +1901,47 @@ public:
         // Copy the edges by adding each edge and copying its
         // property object.
         edge_iterator ei, ei_end;
         for (boost::tie(ei, ei_end) = edges(x); ei != ei_end; ++ei)
         {
             edge_descriptor e;
             bool inserted;
             vertex_descriptor s = source(*ei, x), t = target(*ei, x);
             boost::tie(e, inserted) = add_edge(vertex_map[(stored_vertex*)s],
                 vertex_map[(stored_vertex*)t], *this);
             *((edge_property_type*)e.m_eproperty)
                 = *((edge_property_type*)(*ei).m_eproperty);
         }
     }
 
     typename Config::EdgeContainer m_edges;
     StoredVertexList m_vertices;
 };
 
 // O(1)
-template < class Derived, class Config, class Base >
+template < class Derived, class Config, class Base, class... _AllocArg >
 inline typename Config::vertex_descriptor add_vertex(
-    adj_list_impl< Derived, Config, Base >& g_)
+    adj_list_impl< Derived, Config, Base >& g_, _AllocArg&&... AllocArg)
 {
     Derived& g = static_cast< Derived& >(g_);
     typedef typename Config::stored_vertex stored_vertex;
-    stored_vertex* v = new stored_vertex;
+    stored_vertex* v = new stored_vertex(std::forward<_AllocArg>(AllocArg)...);
     typename Config::StoredVertexList::iterator pos;
     bool inserted;
     boost::tie(pos, inserted) = boost::graph_detail::push(g.m_vertices, v);
     v->m_position = pos;
     g.added_vertex(v);
     return v;
 }
 // O(1)
 template < class Derived, class Config, class Base >
 inline typename Config::vertex_descriptor add_vertex(
     const typename Config::vertex_property_type& p,
     adj_list_impl< Derived, Config, Base >& g_)
 {
     typedef typename Config::vertex_descriptor vertex_descriptor;
     Derived& g = static_cast< Derived& >(g_);
     if (optional< vertex_descriptor > v
         = g.vertex_by_property(get_property_value(p, vertex_bundle)))
         return *v;
 
     typedef typename Config::stored_vertex stored_vertex;
@@ -2103,41 +2104,45 @@ public:
     typedef typename Config::edge_descriptor edge_descriptor;
     typedef typename Config::out_edge_iterator out_edge_iterator;
     typedef typename Config::edge_iterator edge_iterator;
     typedef typename Config::directed_category directed_category;
     typedef typename Config::vertices_size_type vertices_size_type;
     typedef typename Config::edges_size_type edges_size_type;
     typedef typename Config::degree_size_type degree_size_type;
     typedef typename Config::StoredEdge StoredEdge;
     typedef typename Config::stored_vertex stored_vertex;
     typedef typename Config::EdgeContainer EdgeContainer;
     typedef typename Config::edge_property_type edge_property_type;
     typedef vec_adj_list_tag graph_tag;
 
     static vertex_descriptor null_vertex()
     {
         return (std::numeric_limits< vertex_descriptor >::max)();
     }
 
     inline vec_adj_list_impl() {}
 
-    inline vec_adj_list_impl(const vec_adj_list_impl& x) { copy_impl(x); }
+    template<class _AllocArg>
+    inline vec_adj_list_impl(_AllocArg AllocArg) : m_edges(AllocArg), m_vertices(AllocArg) {}
+
+    template<class _AllocArg>
+    inline vec_adj_list_impl(const vec_adj_list_impl& x, _AllocArg AllocArg)  : m_edges(AllocArg), m_vertices(AllocArg) { copy_impl(x); }
     inline vec_adj_list_impl& operator=(const vec_adj_list_impl& x)
     {
         this->clear();
         copy_impl(x);
         return *this;
     }
     inline void clear()
     {
         m_vertices.clear();
         m_edges.clear();
     }
 
     inline vec_adj_list_impl(vertices_size_type _num_vertices)
     : m_vertices(_num_vertices)
     {
     }
 
     template < class EdgeIterator >
     inline vec_adj_list_impl(
         vertices_size_type num_vertices, EdgeIterator first, EdgeIterator last)
@@ -2167,115 +2172,117 @@ public:
     //    protected:
     inline boost::integer_range< vertex_descriptor > vertex_set() const
     {
         return boost::integer_range< vertex_descriptor >(0, m_vertices.size());
     }
     inline OutEdgeList& out_edge_list(vertex_descriptor v)
     {
         return m_vertices[v].m_out_edges;
     }
     inline const OutEdgeList& out_edge_list(vertex_descriptor v) const
     {
         return m_vertices[v].m_out_edges;
     }
     inline void copy_impl(const vec_adj_list_impl& x_)
     {
         const Graph& x = static_cast< const Graph& >(x_);
         // Copy the stored vertex objects by adding each vertex
         // and copying its property object.
         for (vertices_size_type i = 0; i < num_vertices(x); ++i)
         {
-            vertex_descriptor v = add_vertex(*this);
+            vertex_descriptor v = add_vertex(*this, x_.m_vertices.get_allocator());
             m_vertices[v].m_property = x.m_vertices[i].m_property;
         }
         // Copy the edges by adding each edge and copying its
         // property object.
         edge_iterator ei, ei_end;
         for (boost::tie(ei, ei_end) = edges(x); ei != ei_end; ++ei)
         {
             edge_descriptor e;
             bool inserted;
             boost::tie(e, inserted)
                 = add_edge(source(*ei, x), target(*ei, x), *this);
             *((edge_property_type*)e.m_eproperty)
                 = *((edge_property_type*)(*ei).m_eproperty);
         }
     }
     typename Config::EdgeContainer m_edges;
     StoredVertexList m_vertices;
 };
 // Had to make these non-members to avoid accidental instantiation
 // on SGI MIPSpro C++
 template < class G, class C, class B >
 inline typename C::InEdgeList& in_edge_list(
     vec_adj_list_impl< G, C, B >& g, typename C::vertex_descriptor v)
 {
     return g.m_vertices[v].m_in_edges;
 }
 template < class G, class C, class B >
 inline const typename C::InEdgeList& in_edge_list(
     const vec_adj_list_impl< G, C, B >& g, typename C::vertex_descriptor v)
 {
     return g.m_vertices[v].m_in_edges;
 }
 
 // O(1)
-template < class Graph, class Config, class Base >
+template < class Graph, class Config, class Base, class... _AllocArg  >
 inline typename Config::vertex_descriptor add_vertex(
-    vec_adj_list_impl< Graph, Config, Base >& g_)
+    vec_adj_list_impl< Graph, Config, Base >& g_, _AllocArg&&... AllocArg)
 {
     Graph& g = static_cast< Graph& >(g_);
-    g.m_vertices.resize(g.m_vertices.size() + 1);
+    g.m_vertices.emplace_back(std::forward<_AllocArg>(AllocArg)...);
     g.added_vertex(g.m_vertices.size() - 1);
     return g.m_vertices.size() - 1;
 }
 
 template < class Graph, class Config, class Base >
 inline typename Config::vertex_descriptor add_vertex(
     const typename Config::vertex_property_type& p,
     vec_adj_list_impl< Graph, Config, Base >& g_)
 {
     typedef typename Config::vertex_descriptor vertex_descriptor;
     Graph& g = static_cast< Graph& >(g_);
     if (optional< vertex_descriptor > v
         = g.vertex_by_property(get_property_value(p, vertex_bundle)))
         return *v;
     typedef typename Config::stored_vertex stored_vertex;
     g.m_vertices.push_back(stored_vertex(p));
     g.added_vertex(g.m_vertices.size() - 1);
     return g.m_vertices.size() - 1;
 }
 
 // Here we override the directed_graph_helper add_edge() function
 // so that the number of vertices is automatically changed if
 // either u or v is greater than the number of vertices.
-template < class Graph, class Config, class Base >
+template < class Graph, class Config, class Base, class... _AllocArg >
 inline std::pair< typename Config::edge_descriptor, bool > add_edge(
     typename Config::vertex_descriptor u, typename Config::vertex_descriptor v,
     const typename Config::edge_property_type& p,
-    vec_adj_list_impl< Graph, Config, Base >& g_)
+    vec_adj_list_impl< Graph, Config, Base >& g_, _AllocArg&&... AllocArg)
 {
     BOOST_USING_STD_MAX();
+#if 1
     typename Config::vertex_descriptor x
         = max BOOST_PREVENT_MACRO_SUBSTITUTION(u, v);
     if (x >= num_vertices(g_))
-        g_.m_vertices.resize(x + 1);
+        abort(); //g_.m_vertices.resize(x + 1);
+#endif
     adj_list_helper< Config, Base >& g = g_;
     return add_edge(u, v, p, g);
 }
 template < class Graph, class Config, class Base >
 inline std::pair< typename Config::edge_descriptor, bool > add_edge(
     typename Config::vertex_descriptor u, typename Config::vertex_descriptor v,
     vec_adj_list_impl< Graph, Config, Base >& g_)
 {
     typename Config::edge_property_type p;
     return add_edge(u, v, p, g_);
 }
 
 // O(V + E)
 template < class Graph, class Config, class Base >
 inline void remove_vertex(typename Config::vertex_descriptor v,
     vec_adj_list_impl< Graph, Config, Base >& g_)
 {
     typedef typename Config::directed_category Cat;
     Graph& g = static_cast< Graph& >(g_);
     g.removing_vertex(
@@ -2415,75 +2422,78 @@ namespace detail
             typedef adj_list_edge_iterator< vertex_iterator, out_edge_iterator,
                 graph_type >
                 DirectedEdgeIter;
 
             typedef typename mpl::if_< on_edge_storage, DirectedEdgeIter,
                 UndirectedEdgeIter >::type edge_iterator;
 
             // stored_vertex and StoredVertexList
             typedef typename container_gen< VertexListS, vertex_ptr >::type
                 SeqStoredVertexList;
             struct seq_stored_vertex
             {
                 seq_stored_vertex() {}
                 seq_stored_vertex(const VertexProperty& p) : m_property(p) {}
                 OutEdgeList m_out_edges;
                 VertexProperty m_property;
                 typename SeqStoredVertexList::iterator m_position;
             };
             struct bidir_seq_stored_vertex
             {
-                bidir_seq_stored_vertex() {}
+                template<class... _AllocArg>
+                bidir_seq_stored_vertex(_AllocArg&&... AllocArg) : m_out_edges(std::forward<_AllocArg>(AllocArg)...), m_in_edges(std::forward<_AllocArg>(AllocArg)...)  {}
                 bidir_seq_stored_vertex(const VertexProperty& p) : m_property(p)
                 {
                 }
                 OutEdgeList m_out_edges;
                 InEdgeList m_in_edges;
                 VertexProperty m_property;
                 typename SeqStoredVertexList::iterator m_position;
             };
             struct rand_stored_vertex
             {
                 rand_stored_vertex() {}
                 rand_stored_vertex(const VertexProperty& p) : m_property(p) {}
                 OutEdgeList m_out_edges;
                 VertexProperty m_property;
             };
             struct bidir_rand_stored_vertex
             {
-                bidir_rand_stored_vertex() {}
+                template<class... _AllocArg>
+                bidir_rand_stored_vertex(_AllocArg&&... AllocArg) : m_out_edges(std::forward<_AllocArg>(AllocArg)...), m_in_edges(std::forward<_AllocArg>(AllocArg)...) {}
                 bidir_rand_stored_vertex(const VertexProperty& p)
                 : m_property(p)
                 {
                 }
                 OutEdgeList m_out_edges;
                 InEdgeList m_in_edges;
                 VertexProperty m_property;
             };
             typedef typename mpl::if_< is_rand_access,
                 typename mpl::if_< BidirectionalT, bidir_rand_stored_vertex,
                     rand_stored_vertex >::type,
                 typename mpl::if_< BidirectionalT, bidir_seq_stored_vertex,
                     seq_stored_vertex >::type >::type StoredVertex;
             struct stored_vertex : public StoredVertex
             {
-                stored_vertex() {}
+                template<class... _AllocArg>
+                stored_vertex(_AllocArg&&... AllocArg) : StoredVertex(std::forward<_AllocArg>(AllocArg)...) {}
                 stored_vertex(const VertexProperty& p) : StoredVertex(p) {}
             };
 
             typedef typename container_gen< VertexListS, stored_vertex >::type
                 RandStoredVertexList;
             typedef typename mpl::if_< is_rand_access, RandStoredVertexList,
                 SeqStoredVertexList >::type StoredVertexList;
         }; // end of config
 
         typedef typename mpl::if_< BidirectionalT,
             bidirectional_graph_helper_with_property< config >,
             typename mpl::if_< DirectedT, directed_graph_helper< config >,
                 undirected_graph_helper< config > >::type >::type
             DirectedHelper;
 
         typedef typename mpl::if_< is_rand_access,
             vec_adj_list_impl< Graph, config, DirectedHelper >,
             adj_list_impl< Graph, config, DirectedHelper > >::type type;
     };
 
diff --git a/include/boost/pending/container_traits.hpp b/include/boost/pending/container_traits.hpp
index 8bf113a3..9005e5e0 100644
--- a/include/boost/pending/container_traits.hpp
+++ b/include/boost/pending/container_traits.hpp
@@ -5,40 +5,42 @@
 //  accompanying file LICENSE_1_0.txt or copy at
 //  http://www.boost.org/LICENSE_1_0.txt)
 
 #ifndef BOOST_GRAPH_DETAIL_CONTAINER_TRAITS_H
 #define BOOST_GRAPH_DETAIL_CONTAINER_TRAITS_H
 
 // Sure would be nice to be able to forward declare these
 // instead of pulling in all the headers. Too bad that
 // is not legal. There ought to be a standard <stlfwd> header. -JGS
 
 #include <boost/next_prior.hpp>
 
 #include <algorithm> // for std::remove
 #include <utility>
 #include <vector>
 #include <list>
 #include <map>
 #include <set>
 #include <boost/unordered_set.hpp>
 #include <boost/unordered_map.hpp>
+#include <boost/container/list.hpp>
+#include <boost/container/vector.hpp>
 
 #ifndef BOOST_NO_CXX11_HDR_UNORDERED_SET
 #include <unordered_set>
 #endif
 
 #ifndef BOOST_NO_CXX11_HDR_UNORDERED_MAP
 #include <unordered_map>
 #endif
 
 #ifdef BOOST_NO_CXX11_RVALUE_REFERENCES
 #define BOOST_PENDING_FWD_TYPE(type) const type&
 #define BOOST_PENDING_FWD_VALUE(type, var) (var)
 #else
 #define BOOST_PENDING_FWD_TYPE(type) type&&
 #define BOOST_PENDING_FWD_VALUE(type, var) (std::forward< type >((var)))
 #endif
 
 // The content of this file is in 'graph_detail' because otherwise
 // there will be name clashes with
 // sandbox/boost/sequence_algo/container_traits.hpp
@@ -139,93 +141,154 @@ namespace graph_detail
 
     template < class T, class Alloc >
     vector_tag container_category(const std::vector< T, Alloc >&)
     {
         return vector_tag();
     }
 
     template < class T, class Alloc >
     unstable_tag iterator_stability(const std::vector< T, Alloc >&)
     {
         return unstable_tag();
     }
 
     template < class T, class Alloc >
     struct container_traits< std::vector< T, Alloc > >
     {
         typedef vector_tag category;
         typedef unstable_tag iterator_stability;
     };
 
+    // boost::vector
+    template < class T, class Alloc >
+    vector_tag container_category(const boost::container::vector< T, Alloc >&)
+    {
+        return vector_tag();
+    }
+
+    template < class T, class Alloc >
+    unstable_tag iterator_stability(const boost::container::vector< T, Alloc >&)
+    {
+        return unstable_tag();
+    }
+
+    template < class T, class Alloc >
+    struct container_traits< boost::container::vector< T, Alloc > >
+    {
+        typedef vector_tag category;
+        typedef unstable_tag iterator_stability;
+    };
+
     // std::list
     struct list_tag : virtual public reversible_container_tag,
                       virtual public back_insertion_sequence_tag
     // this causes problems for push_dispatch...
     //    virtual public front_insertion_sequence_tag
     {
     };
 
     template < class T, class Alloc >
     list_tag container_category(const std::list< T, Alloc >&)
     {
         return list_tag();
     }
 
     template < class T, class Alloc >
     stable_tag iterator_stability(const std::list< T, Alloc >&)
     {
         return stable_tag();
     }
 
     template < class T, class Alloc >
     struct container_traits< std::list< T, Alloc > >
     {
         typedef list_tag category;
         typedef stable_tag iterator_stability;
     };
 
+    // list
+    template < class T, class Alloc >
+    list_tag container_category(const boost::container::list< T, Alloc >&)
+    {
+        return list_tag();
+    }
+
+    template < class T, class Alloc >
+    stable_tag iterator_stability(const boost::container::list< T, Alloc >&)
+    {
+        return stable_tag();
+    }
+
+    template < class T, class Alloc >
+    struct container_traits< boost::container::list< T, Alloc > >
+    {
+        typedef list_tag category;
+        typedef stable_tag iterator_stability;
+    };
+
+
     // std::set
     struct set_tag : virtual public sorted_associative_container_tag,
                      virtual public simple_associative_container_tag,
                      virtual public unique_associative_container_tag
     {
     };
 
     template < class Key, class Cmp, class Alloc >
     set_tag container_category(const std::set< Key, Cmp, Alloc >&)
     {
         return set_tag();
     }
 
     template < class Key, class Cmp, class Alloc >
     stable_tag iterator_stability(const std::set< Key, Cmp, Alloc >&)
     {
         return stable_tag();
     }
 
     template < class Key, class Cmp, class Alloc >
     struct container_traits< std::set< Key, Cmp, Alloc > >
     {
         typedef set_tag category;
         typedef stable_tag iterator_stability;
     };
 
+    // boost::container::set
+    template < class Key, class Cmp, class Alloc >
+    set_tag container_category(const boost::container::set< Key, Cmp, Alloc >&)
+    {
+        return set_tag();
+    }
+
+    template < class Key, class Cmp, class Alloc >
+    stable_tag iterator_stability(const boost::container::set< Key, Cmp, Alloc >&)
+    {
+        return stable_tag();
+    }
+
+    template < class Key, class Cmp, class Alloc >
+    struct container_traits< boost::container::set< Key, Cmp, Alloc > >
+    {
+        typedef set_tag category;
+        typedef stable_tag iterator_stability;
+    };
+
     // std::multiset
     struct multiset_tag : virtual public sorted_associative_container_tag,
                           virtual public simple_associative_container_tag,
                           virtual public multiple_associative_container_tag
     {
     };
 
     template < class Key, class Cmp, class Alloc >
     multiset_tag container_category(const std::multiset< Key, Cmp, Alloc >&)
     {
         return multiset_tag();
     }
 
     template < class Key, class Cmp, class Alloc >
     stable_tag iterator_stability(const std::multiset< Key, Cmp, Alloc >&)
     {
         return stable_tag();
     }
 
     template < class Key, class Cmp, class Alloc >
