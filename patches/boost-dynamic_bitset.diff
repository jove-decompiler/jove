diff --git a/include/boost/dynamic_bitset/dynamic_bitset.hpp b/include/boost/dynamic_bitset/dynamic_bitset.hpp
index 6cc4364..a34ffc3 100644
--- a/include/boost/dynamic_bitset/dynamic_bitset.hpp
+++ b/include/boost/dynamic_bitset/dynamic_bitset.hpp
@@ -34,59 +34,65 @@
 #endif
 
 #if defined(BOOST_OLD_IOSTREAMS)
 #  include <iostream.h>
 #  include <ctype.h> // for isspace
 #else
 #  include <istream>
 #  include <ostream>
 #endif
 
 #include "boost/dynamic_bitset_fwd.hpp"
 #include "boost/dynamic_bitset/detail/dynamic_bitset.hpp"
 #include "boost/dynamic_bitset/detail/lowest_bit.hpp"
 #include "boost/move/move.hpp"
 #include "boost/limits.hpp"
 #include "boost/static_assert.hpp"
 #include "boost/core/addressof.hpp"
 #include "boost/core/no_exceptions_support.hpp"
 #include "boost/throw_exception.hpp"
 #include "boost/functional/hash/hash.hpp"
+#include "boost/container/vector.hpp"
 
 
 namespace boost {
 
 template <typename Block, typename Allocator>
 class dynamic_bitset
 {
     // Portability note: member function templates are defined inside
     // this class definition to avoid problems with VC++. Similarly,
     // with the member functions of nested classes.
     //
     // [October 2008: the note above is mostly historical; new versions
     // of VC++ are likely able to digest a more drinking form of the
     // code; but changing it now is probably not worth the risks...]
 
     BOOST_STATIC_ASSERT((bool)detail::dynamic_bitset_impl::allowed_block_type<Block>::value);
-    typedef std::vector<Block, Allocator> buffer_type;
 
-public:
+    typedef boost::container::vector_options<
+        boost::container::stored_size<uint32_t>>::type VectorOptions;
+
+    typedef boost::interprocess::vector<Block, Allocator, VectorOptions>
+        buffer_type;
+
+  public:
     typedef Block block_type;
     typedef Allocator allocator_type;
     typedef std::size_t size_type;
     typedef typename buffer_type::size_type block_width_type;
 
     BOOST_STATIC_CONSTANT(block_width_type, bits_per_block = (std::numeric_limits<Block>::digits));
     BOOST_STATIC_CONSTANT(size_type, npos = static_cast<size_type>(-1));
 
 
 public:
 
     // A proxy class to simulate lvalues of bit type.
     //
     class reference
     {
         friend class dynamic_bitset<Block, Allocator>;
 
 
         // the one and only non-copy ctor
         reference(block_type & b, block_width_type pos)
