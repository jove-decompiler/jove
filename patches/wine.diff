diff --git a/dlls/ntdll/sync.c b/dlls/ntdll/sync.c
index 522ce0a2142..83d09035396 100644
--- a/dlls/ntdll/sync.c
+++ b/dlls/ntdll/sync.c
@@ -281,41 +281,41 @@ NTSTATUS WINAPI RtlDeleteCriticalSection( RTL_CRITICAL_SECTION *crit )
         /* only free the ones we made in here */
         if (!crit->DebugInfo->Spare[0])
         {
             RtlFreeHeap( GetProcessHeap(), 0, crit->DebugInfo );
             crit->DebugInfo = NULL;
         }
     }
     else crit->DebugInfo = NULL;
 
     if ((sem = get_semaphore( crit ))) NtClose( sem );
     crit->LockSemaphore = 0;
     return STATUS_SUCCESS;
 }
 
 
 /******************************************************************************
  *      RtlpWaitForCriticalSection   (NTDLL.@)
  */
 NTSTATUS WINAPI RtlpWaitForCriticalSection( RTL_CRITICAL_SECTION *crit )
 {
-    unsigned int timeout = 5;
+    unsigned int timeout = 30;
 
     /* Don't allow blocking on a critical section during process termination */
     if (RtlDllShutdownInProgress())
     {
         WARN( "process %s is shutting down, returning STATUS_SUCCESS\n",
               debugstr_w(NtCurrentTeb()->Peb->ProcessParameters->ImagePathName.Buffer) );
         return STATUS_SUCCESS;
     }
 
     for (;;)
     {
         NTSTATUS status = wait_semaphore( crit, timeout );
 
         if (status == STATUS_WAIT_0) break;
         if (status != WAIT_TIMEOUT) return status;
 
         timeout = (TRACE_ON(relay) ? 300 : 60);
 
         ERR( "section %p %s wait timed out in thread %04lx, blocked by %04lx, retrying (%u sec)\n",
              crit, debugstr_a(crit_section_get_name(crit)), GetCurrentThreadId(), HandleToULong(crit->OwningThread), timeout );
diff --git a/dlls/ntdll/unix/debug.c b/dlls/ntdll/unix/debug.c
index e84a47f58a4..06501a502a3 100644
--- a/dlls/ntdll/unix/debug.c
+++ b/dlls/ntdll/unix/debug.c
@@ -16,66 +16,68 @@
  * You should have received a copy of the GNU Lesser General Public
  * License along with this library; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
 #if 0
 #pragma makedep unix
 #endif
 
 #include "config.h"
 
 #include <assert.h>
 #include <fcntl.h>
 #include <stdarg.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 #include <sys/types.h>
 #include <sys/stat.h>
 #include <unistd.h>
+#include <errno.h>
 
 #include "ntstatus.h"
 #define WIN32_NO_STATUS
 #include "windef.h"
 #include "winnt.h"
 #include "winternl.h"
 #include "unix_private.h"
 #include "wine/debug.h"
 
 WINE_DECLARE_DEBUG_CHANNEL(pid);
 WINE_DECLARE_DEBUG_CHANNEL(timestamp);
 WINE_DEFAULT_DEBUG_CHANNEL(ntdll);
 
 struct debug_info
 {
     unsigned int str_pos;       /* current position in strings buffer */
     unsigned int out_pos;       /* current position in output buffer */
     char         strings[1020]; /* buffer for temporary strings */
     char         output[1020];  /* current output line */
 };
 
 C_ASSERT( sizeof(struct debug_info) == 0x800 );
 
 static BOOL init_done;
 static struct debug_info initial_info;  /* debug info for initial thread */
 static unsigned char default_flags = (1 << __WINE_DBCL_ERR) | (1 << __WINE_DBCL_FIXME);
+int logfd = 2;
 static int nb_debug_options = -1;
 static int options_size;
 static struct __wine_debug_channel *debug_options;
 
 static const char * const debug_classes[] = { "fixme", "err", "warn", "trace" };
 
 /* get the debug info pointer for the current thread */
 static inline struct debug_info *get_info(void)
 {
     if (!init_done) return &initial_info;
 #ifdef _WIN64
     return (struct debug_info *)((TEB32 *)((char *)NtCurrentTeb() + teb_offset) + 1);
 #else
     return (struct debug_info *)(NtCurrentTeb() + 1);
 #endif
 }
 
 /* add a string to the output buffer */
 static int append_output( struct debug_info *info, const char *str, size_t len )
 {
@@ -183,46 +185,61 @@ static void parse_options( const char *str, const char *app_name )
     }
     free( options );
 }
 
 /* print the usage message */
 static void debug_usage(void)
 {
     static const char usage[] =
         "Syntax of the WINEDEBUG variable:\n"
         "  WINEDEBUG=[[process:]class]+xxx,[[process:]class]-yyy,...\n\n"
         "Example: WINEDEBUG=+relay,warn-heap\n"
         "    turns on relay traces, disable heap warnings\n"
         "Available message classes: err, warn, fixme, trace\n";
     write( 2, usage, sizeof(usage) - 1 );
     exit(1);
 }
 
 /* initialize all options at startup */
 static void init_options(void)
 {
+    char *wine_debug_log = getenv("WINEDEBUGLOG");
     char *wine_debug = getenv("WINEDEBUG");
     const char *app_name, *p;
     struct stat st1, st2;
 
     nb_debug_options = 0;
 
+    if (wine_debug_log) {
+        logfd = open(wine_debug_log, O_CREAT | O_WRONLY | /* O_TRUNC */ O_APPEND, 0666);
+        if (logfd < 0) {
+            char buffer[MAX_PATH + 1];
+
+            int slen = snprintf(buffer, sizeof(buffer),
+                                "could open wine debug log at \"%s\": %s",
+                                wine_debug_log, strerror(errno));
+
+            write(2, buffer, slen);
+            exit(1);
+        }
+    }
+
     /* check for stderr pointing to /dev/null */
     if (!fstat( 2, &st1 ) && S_ISCHR(st1.st_mode) &&
         !stat( "/dev/null", &st2 ) && S_ISCHR(st2.st_mode) &&
         st1.st_rdev == st2.st_rdev)
     {
         default_flags = 0;
         return;
     }
     if (!wine_debug) return;
     if (!strcmp( wine_debug, "help" )) debug_usage();
 
     app_name = main_argv[1];
     while ((p = strpbrk( app_name, "/\\" ))) app_name = p + 1;
 
     parse_options( wine_debug, app_name );
 }
 
 /***********************************************************************
  *		__wine_dbg_get_channel_flags  (NTDLL.@)
  *
@@ -262,72 +279,72 @@ unsigned char __cdecl __wine_dbg_get_channel_flags( struct __wine_debug_channel
  */
 const char * __cdecl __wine_dbg_strdup( const char *str )
 {
     struct debug_info *info = get_info();
     unsigned int pos = info->str_pos;
     size_t n = strlen( str ) + 1;
 
     assert( n <= sizeof(info->strings) );
     if (pos + n > sizeof(info->strings)) pos = 0;
     info->str_pos = pos + n;
     return memcpy( info->strings + pos, str, n );
 }
 
 /***********************************************************************
  *		unixcall_wine_dbg_write
  */
 NTSTATUS unixcall_wine_dbg_write( void *args )
 {
     struct wine_dbg_write_params *params = args;
 
-    return write( 2, params->str, params->len );
+    return write( logfd, params->str, params->len );
 }
 
 #ifdef _WIN64
 /***********************************************************************
  *		wow64_wine_dbg_write
  */
 NTSTATUS wow64_wine_dbg_write( void *args )
 {
     struct
     {
         ULONG        str;
         unsigned int len;
     } const *params32 = args;
 
     return write( 2, ULongToPtr(params32->str), params32->len );
 }
 #endif
 
 /***********************************************************************
  *		__wine_dbg_output  (NTDLL.@)
  */
 int __cdecl __wine_dbg_output( const char *str )
 {
     struct debug_info *info = get_info();
     const char *end = strrchr( str, '\n' );
     int ret = 0;
 
     if (end)
     {
         ret += append_output( info, str, end + 1 - str );
-        write( 2, info->output, info->out_pos );
+        write( logfd, info->output, info->out_pos );
         info->out_pos = 0;
         str = end + 1;
     }
     if (*str) ret += append_output( info, str, strlen( str ));
     return ret;
 }
 
 /***********************************************************************
  *		__wine_dbg_header  (NTDLL.@)
  */
 int __cdecl __wine_dbg_header( enum __wine_debug_class cls, struct __wine_debug_channel *channel,
                                const char *function )
 {
     static const char * const classes[] = { "fixme", "err", "warn", "trace" };
     struct debug_info *info = get_info();
     char *pos = info->output;
 
     if (!(__wine_dbg_get_channel_flags( channel ) & (1 << cls))) return -1;
 
     /* only print header if we are at the beginning of the line */
diff --git a/dlls/ntdll/unix/loader.c b/dlls/ntdll/unix/loader.c
index ecbcd439ee7..b61cb5e5d78 100644
--- a/dlls/ntdll/unix/loader.c
+++ b/dlls/ntdll/unix/loader.c
@@ -287,41 +287,51 @@ static char *build_relative_path( const char *base, const char *from, const char
         while (*from);
         break;
     }
 
     ret = malloc( strlen(base) + 3 * dotdots + strlen(start) + 2 );
     strcpy( ret, base );
     while (dotdots--) strcat( ret, "/.." );
 
     if (!start[0]) return ret;
     strcat( ret, "/" );
     strcat( ret, start );
     return ret;
 }
 
 /* build a path to a binary and exec it */
 static int build_path_and_exec( pid_t *pid, const char *dir, const char *name, char **argv )
 {
     int ret;
 
     argv[0] = build_path( dir, name );
+#if 1
     ret = posix_spawn( pid, argv[0], NULL, NULL, argv, environ );
+#else
+    pid_t child = fork();
+    if (!child)
+      execve(argv[0], argv, environ);
+    else
+      *pid = child;
+    ret = 0;
+#endif
+
     free( argv[0] );
     return ret;
 }
 
 
 static const char *get_so_dir( WORD machine )
 {
     switch (machine)
     {
     case IMAGE_FILE_MACHINE_I386:  return "/i386-unix";
     case IMAGE_FILE_MACHINE_AMD64: return "/x86_64-unix";
     case IMAGE_FILE_MACHINE_ARMNT: return "/arm-unix";
     case IMAGE_FILE_MACHINE_ARM64: return "/aarch64-unix";
     default: return "";
     }
 }
 
 static const char *get_pe_dir( WORD machine )
 {
     switch(machine)
@@ -578,43 +588,44 @@ static int exec_wineserver( pid_t *pid, char **argv )
 /***********************************************************************
  *           start_server
  *
  * Start a new wine server.
  */
 void start_server( BOOL debug )
 {
     static BOOL started;  /* we only try once */
     char *argv[3];
     static char debug_flag[] = "-d";
 
     if (!started)
     {
         int status;
         pid_t pid;
 
         argv[1] = debug ? debug_flag : NULL;
         argv[2] = NULL;
         if (exec_wineserver( &pid, argv )) fatal_error( "could not exec wineserver\n" );
         waitpid( pid, &status, 0 );
+
         status = WIFEXITED(status) ? WEXITSTATUS(status) : 1;
         if (status == 2) return;  /* server lock held by someone else, will retry later */
-        if (status) exit(status);  /* server failed */
+        //if (status) exit(status);  /* server failed */
         started = TRUE;
     }
 }
 
 
 /***********************************************************************
  *           KeAddSystemServiceTable
  */
 BOOLEAN KeAddSystemServiceTable( ULONG_PTR *funcs, ULONG_PTR *counters, ULONG limit,
                                  BYTE *arguments, ULONG index )
 {
     if (index >= ARRAY_SIZE(KeServiceDescriptorTable)) return FALSE;
     KeServiceDescriptorTable[index].ServiceTable  = funcs;
     KeServiceDescriptorTable[index].CounterTable  = counters;
     KeServiceDescriptorTable[index].ServiceLimit  = limit;
     KeServiceDescriptorTable[index].ArgumentTable = arguments;
     return TRUE;
 }
 
 
@@ -2164,42 +2175,44 @@ static void reexec_loader( int argc, char *argv[], char *extra_arg )
 {
     static char noexec[] = "WINELOADERNOEXEC=1";
     WORD machine = current_machine;
     char **new_argv;
 
     /* have to exec if we have a preloader, or an argument, or if we are the initial wrapper */
     if (!pre_exec() && !extra_arg && dlsym( RTLD_DEFAULT, "wine_main_preload_info" )) return;
 
     if (extra_arg)
     {
         new_argv = malloc( (argc + 3) * sizeof(*argv) );
         memcpy( new_argv + 3, argv + 1, argc * sizeof(*argv) );
         new_argv[2] = extra_arg;
     }
     else
     {
         new_argv = malloc( (argc + 2) * sizeof(*argv) );
         memcpy( new_argv + 2, argv + 1, argc * sizeof(*argv) );
     }
 
+#if 0 /* FIXME???? */
     /* default to 32-bit loader to support 32-bit prefixes */
     if (machine == IMAGE_FILE_MACHINE_AMD64) machine = IMAGE_FILE_MACHINE_I386;
+#endif
 
     putenv( noexec );
     loader_exec( new_argv, machine );
     fatal_error( "could not exec the wine loader\n" );
 }
 
 /***********************************************************************
  *           check_command_line
  *
  * Check if command line is one that needs to be handled specially.
  */
 static void check_command_line( int argc, char *argv[] )
 {
     char *basename;
     static const char usage[] =
         "Usage: wine PROGRAM [ARGUMENTS...]   Run the specified program\n"
         "       wine --help                   Display this help and exit\n"
         "       wine --version                Output version information and exit";
 
     if ((basename = strrchr( argv[0], '/' ))) basename++;
diff --git a/dlls/ntdll/unix/server.c b/dlls/ntdll/unix/server.c
index a6e07215479..46830d2430b 100644
--- a/dlls/ntdll/unix/server.c
+++ b/dlls/ntdll/unix/server.c
@@ -1580,43 +1580,45 @@ size_t server_init_process(void)
     pthread_sigmask( SIG_BLOCK, &server_block_set, NULL );
 
     /* receive the first thread request fd on the main socket */
     ntdll_get_thread_data()->request_fd = receive_fd( &version );
 
 #ifdef SO_PASSCRED
     /* now that we hopefully received the server_pid, disable SO_PASSCRED */
     {
         int enable = 0;
         setsockopt( fd_socket, SOL_SOCKET, SO_PASSCRED, &enable, sizeof(enable) );
     }
 #endif
 
     if (version != SERVER_PROTOCOL_VERSION)
         server_protocol_error( "version mismatch %d/%d.\n"
                                "Your %s binary was not upgraded correctly,\n"
                                "or you have an older one somewhere in your PATH.\n"
                                "Or maybe the wrong wineserver is still running?\n",
                                version, SERVER_PROTOCOL_VERSION,
                                (version > SERVER_PROTOCOL_VERSION) ? "wine" : "wineserver" );
+#if 0
 #if defined(__linux__) && defined(HAVE_PRCTL)
     /* work around Ubuntu's ptrace breakage */
     if (server_pid != -1) prctl( 0x59616d61 /* PR_SET_PTRACER */, server_pid );
+#endif
 #endif
 
     /* ignore SIGPIPE so that we get an EPIPE error instead  */
     sig_act.sa_handler = SIG_IGN;
     sig_act.sa_flags   = 0;
     sigemptyset( &sig_act.sa_mask );
     sigaction( SIGPIPE, &sig_act, NULL );
 
     reply_pipe = init_thread_pipe();
 
     SERVER_START_REQ( init_first_thread )
     {
         req->unix_pid    = getpid();
         req->unix_tid    = get_unix_tid();
         req->reply_fd    = reply_pipe;
         req->wait_fd     = ntdll_get_thread_data()->wait_fd[1];
         req->debug_level = (TRACE_ON(server) != 0);
         wine_server_set_reply( req, supported_machines, sizeof(supported_machines) );
         ret = wine_server_call( req );
         pid               = reply->pid;
diff --git a/dlls/ntdll/unix/signal_i386.c b/dlls/ntdll/unix/signal_i386.c
index bdcb6bfed09..56ec841e978 100644
--- a/dlls/ntdll/unix/signal_i386.c
+++ b/dlls/ntdll/unix/signal_i386.c
@@ -1452,40 +1452,41 @@ static void setup_raise_exception( ucontext_t *sigcontext, void *stack_ptr,
                                    EXCEPTION_RECORD *rec, struct xcontext *xcontext )
 {
     CONTEXT *context = &xcontext->c;
     XSAVE_AREA_HEADER *src_xs;
     struct exc_stack_layout *stack;
     size_t stack_size;
     unsigned int xstate_size;
     NTSTATUS status = send_debug_event( rec, context, TRUE, TRUE );
 
     if (status == DBG_CONTINUE || status == DBG_EXCEPTION_HANDLED)
     {
         restore_context( xcontext, sigcontext );
         return;
     }
 
     /* fix up instruction pointer in context for EXCEPTION_BREAKPOINT */
     if (rec->ExceptionCode == EXCEPTION_BREAKPOINT) context->Eip--;
 
     xstate_size = sizeof(XSAVE_AREA_HEADER) + xstate_features_size;
     stack_size = (ULONG_PTR)stack_ptr - (((ULONG_PTR)stack_ptr - sizeof(*stack) - xstate_size) & ~(ULONG_PTR)63);
+
     stack = virtual_setup_exception( stack_ptr, stack_size, rec );
     stack->rec_ptr      = &stack->rec;
     stack->context_ptr  = &stack->context;
     stack->rec          = *rec;
     stack->context      = *context;
 
     if ((src_xs = xstate_from_context( context )))
     {
         XSAVE_AREA_HEADER *dst_xs = (XSAVE_AREA_HEADER *)(stack + 1);
 
         assert( !((ULONG_PTR)dst_xs & 63) );
         context_init_xstate( &stack->context, dst_xs );
         memset( dst_xs, 0, sizeof(*dst_xs) );
         dst_xs->CompactionMask = xstate_compaction_enabled ? 0x8000000000000000 | xstate_extended_features() : 0;
         copy_xstate( dst_xs, src_xs, src_xs->Mask );
     }
     else
     {
         context_init_xstate( &stack->context, NULL );
     }
diff --git a/dlls/ntdll/unix/virtual.c b/dlls/ntdll/unix/virtual.c
index ca5d50b0fe6..34f0bdbb9e9 100644
--- a/dlls/ntdll/unix/virtual.c
+++ b/dlls/ntdll/unix/virtual.c
@@ -19,40 +19,42 @@
  */
 
 #if 0
 #pragma makedep unix
 #endif
 
 #include "config.h"
 
 #include <assert.h>
 #include <errno.h>
 #include <fcntl.h>
 #include <stdarg.h>
 #include <stdio.h>
 #include <string.h>
 #include <stdlib.h>
 #include <signal.h>
 #include <sys/types.h>
 #include <sys/socket.h>
 #include <sys/stat.h>
 #include <sys/mman.h>
+#include <sys/prctl.h>
+#include <linux/prctl.h>
 #ifdef HAVE_SYS_SYSINFO_H
 # include <sys/sysinfo.h>
 #endif
 #ifdef HAVE_SYS_SYSCALL_H
 # include <sys/syscall.h>
 #endif
 #ifdef HAVE_SYS_SYSCTL_H
 # include <sys/sysctl.h>
 #endif
 #ifdef HAVE_SYS_PARAM_H
 # include <sys/param.h>
 #endif
 #ifdef HAVE_SYS_QUEUE_H
 # include <sys/queue.h>
 #endif
 #ifdef HAVE_SYS_USER_H
 # include <sys/user.h>
 #endif
 #ifdef HAVE_LIBPROCSTAT_H
 # include <libprocstat.h>
@@ -66,40 +68,42 @@
 #define host_page_size mac_host_page_size
 # include <mach/mach_init.h>
 # include <mach/mach_vm.h>
 # include <mach/task.h>
 # include <mach/thread_state.h>
 # include <mach/vm_map.h>
 #undef host_page_size
 #endif
 
 #include "ntstatus.h"
 #define WIN32_NO_STATUS
 #include "windef.h"
 #include "winnt.h"
 #include "winternl.h"
 #include "ddk/wdm.h"
 #include "wine/list.h"
 #include "wine/rbtree.h"
 #include "unix_private.h"
 #include "wine/debug.h"
 
+extern int logfd;
+
 WINE_DEFAULT_DEBUG_CHANNEL(virtual);
 WINE_DECLARE_DEBUG_CHANNEL(module);
 WINE_DECLARE_DEBUG_CHANNEL(virtual_ranges);
 
 struct preload_info
 {
     void  *addr;
     size_t size;
 };
 
 struct reserved_area
 {
     struct list entry;
     void       *base;
     size_t      size;
 };
 
 static struct list reserved_areas = LIST_INIT(reserved_areas);
 
 struct builtin_module
@@ -207,41 +211,41 @@ static struct list teb_list = LIST_INIT( teb_list );
 #define VIRTUAL_DEBUG_DUMP_VIEW(view) do { if (TRACE_ON(virtual)) dump_view(view); } while (0)
 #define VIRTUAL_DEBUG_DUMP_RANGES() do { if (TRACE_ON(virtual_ranges)) dump_free_ranges(); } while (0)
 
 #ifndef MAP_NORESERVE
 #define MAP_NORESERVE 0
 #endif
 
 #ifdef _WIN64  /* on 64-bit the page protection bytes use a 2-level table */
 static const size_t pages_vprot_shift = 20;
 static const size_t pages_vprot_mask = (1 << 20) - 1;
 static size_t pages_vprot_size;
 static BYTE **pages_vprot;
 #else  /* on 32-bit we use a simple array with one byte per page */
 static BYTE *pages_vprot;
 #endif
 
 static struct file_view *view_block_start, *view_block_end, *next_free_view;
 static const size_t view_block_size = 0x100000;
 static void *preload_reserve_start;
 static void *preload_reserve_end;
-static BOOL force_exec_prot;  /* whether to force PROT_EXEC on all PROT_READ mmaps */
+static BOOL force_exec_prot = TRUE;  /* whether to force PROT_EXEC on all PROT_READ mmaps */
 static BOOL enable_write_exceptions;  /* raise exception on writes to executable memory */
 
 struct range_entry
 {
     void *base;
     void *end;
 };
 
 static struct range_entry *free_ranges;
 static struct range_entry *free_ranges_end;
 
 
 static inline BOOL is_beyond_limit( const void *addr, size_t size, const void *limit )
 {
     return (addr >= limit || (const char *)addr + size > (const char *)limit);
 }
 
 static inline BOOL is_vprot_exec_write( BYTE vprot )
 {
     return (vprot & VPROT_EXEC) && (vprot & (VPROT_WRITE | VPROT_WRITECOPY));
@@ -2222,40 +2226,48 @@ static NTSTATUS map_file_into_view( struct file_view *view, int fd, size_t start
                 if (prot & PROT_EXEC) ERR( "failed to set PROT_EXEC on file map, noexec filesystem?\n" );
                 return STATUS_ACCESS_DENIED;
             }
             if (prot & PROT_EXEC) WARN( "failed to set PROT_EXEC on file map, noexec filesystem?\n" );
             break;
         default:
             ERR( "mmap error %s, range %p-%p, unix_prot %#x\n",
                  strerror(errno), map_addr, map_addr + map_size, prot );
             return STATUS_NO_MEMORY;
         }
     }
 
     if (vprot & VPROT_WRITE)
     {
         ERR( "unaligned shared mapping %p-%p not supported\n", map_addr, map_addr + map_size );
         return STATUS_INVALID_PARAMETER;
     }
 
     mprotect( map_addr, map_size, PROT_READ | PROT_WRITE );
     pread( fd, map_addr, size, offset );
+
+    {
+      char buff[65];
+      snprintf(buff, sizeof(buff), "%d:%u", dup(fd), (unsigned)offset);
+
+      prctl(PR_SET_VMA, PR_SET_VMA_ANON_NAME, (unsigned long)map_addr, (unsigned long)map_size, buff);
+    }
+
     return STATUS_SUCCESS;
 }
 
 
 /***********************************************************************
  *           get_committed_size
  *
  * Get the size of the committed range with equal masked vprot bytes starting at base.
  * Also return the protections for the first page.
  */
 static SIZE_T get_committed_size( struct file_view *view, void *base, size_t max_size, BYTE *vprot, BYTE vprot_mask )
 {
     SIZE_T offset, size;
 
     base = ROUND_ADDR( base, page_mask );
     offset = (char *)base - (char *)view->base;
 
     if (view->protect & SEC_RESERVE)
     {
         size = 0;
@@ -2826,61 +2838,77 @@ static IMAGE_BASE_RELOCATION *process_relocation_block( char *page, IMAGE_BASE_R
             WORD hi = ((inst[1] << 1) & 0x0800) + ((inst[1] << 12) & 0xf000) +
                       ((inst[1] >> 20) & 0x0700) + ((inst[1] >> 16) & 0x00ff);
             DWORD imm = MAKELONG( lo, hi ) + delta;
 
             lo = LOWORD( imm );
             hi = HIWORD( imm );
             inst[0] = (inst[0] & 0x8f00fbf0) + ((lo >> 1) & 0x0400) + ((lo >> 12) & 0x000f) +
                                                ((lo << 20) & 0x70000000) + ((lo << 16) & 0xff0000);
             inst[1] = (inst[1] & 0x8f00fbf0) + ((hi >> 1) & 0x0400) + ((hi >> 12) & 0x000f) +
                                                ((hi << 20) & 0x70000000) + ((hi << 16) & 0xff0000);
             break;
         }
         default:
             FIXME( "Unknown/unsupported relocation %x\n", *reloc );
             return NULL;
         }
     }
     return (IMAGE_BASE_RELOCATION *)reloc;  /* return address of next block */
 }
 
+static ssize_t path_of_fd(int fd, char *out, size_t len) {
+  ssize_t ret;
+
+  char buff[256];
+  snprintf(buff, sizeof(buff), "/proc/self/fd/%d", fd);
+
+  ret = readlink(buff, out, len);
+
+  if (ret > 0 && ret < len)
+    out[ret] = '\0';
+  else
+    return -1;
+
+  return ret;
+}
 
 /***********************************************************************
  *           map_image_into_view
  *
  * Map an executable (PE format) image into an existing view.
  * virtual_mutex must be held by caller.
  */
 static NTSTATUS map_image_into_view( struct file_view *view, const WCHAR *filename, int fd,
                                      struct pe_image_info *image_info, USHORT machine,
                                      int shared_fd, BOOL removable )
 {
     IMAGE_DOS_HEADER *dos;
     IMAGE_NT_HEADERS *nt;
     IMAGE_SECTION_HEADER *sections = NULL, *sec;
     IMAGE_DATA_DIRECTORY *imports, *dir;
     NTSTATUS status = STATUS_CONFLICTING_ADDRESSES;
     int i;
     off_t pos;
     struct stat st;
     char *header_end;
     char *ptr = view->base;
+    char fd_path[MAX_PATH+1];
     SIZE_T header_size, header_map_size, total_size = view->size;
     SIZE_T align_mask = max( image_info->alignment - 1, page_mask );
     INT_PTR delta;
 
     TRACE_(module)( "mapping PE file %s at %p-%p\n", debugstr_w(filename), ptr, ptr + total_size );
 
     /* map the header */
 
     fstat( fd, &st );
     header_size = min( image_info->header_size, st.st_size );
     header_map_size = min( image_info->header_map_size, ROUND_SIZE( 0, st.st_size, host_page_mask ));
     if ((status = map_pe_header( view->base, header_size, header_map_size, fd, &removable )))
         return status;
 
     status = STATUS_INVALID_IMAGE_FORMAT;  /* generic error */
     dos = (IMAGE_DOS_HEADER *)ptr;
     nt = (IMAGE_NT_HEADERS *)(ptr + dos->e_lfanew);
     header_end = ptr + ROUND_SIZE( 0, header_size, align_mask );
     memset( ptr + header_size, 0, header_end - (ptr + header_size) );
     if ((char *)(nt + 1) > header_end) return status;
@@ -2964,41 +2992,41 @@ static NTSTATUS map_image_into_view( struct file_view *view, const WCHAR *filena
                 goto done;
             }
 
             /* check if the import directory falls inside this section */
             if (imports && imports->VirtualAddress >= sec[i].VirtualAddress &&
                 imports->VirtualAddress < sec[i].VirtualAddress + map_size)
             {
                 UINT_PTR base = imports->VirtualAddress & ~host_page_mask;
                 UINT_PTR end = base + ROUND_SIZE( imports->VirtualAddress, imports->Size, host_page_mask );
                 if (end > sec[i].VirtualAddress + map_size) end = sec[i].VirtualAddress + map_size;
                 if (end > base)
                     map_file_into_view( view, shared_fd, base, end - base,
                                         pos + (base - sec[i].VirtualAddress),
                                         VPROT_COMMITTED | VPROT_READ | VPROT_WRITECOPY, FALSE );
             }
             pos += map_size;
             continue;
         }
 
         TRACE_(module)( "mapping %s section %.8s at %p off %x size %x virt %x flags %x\n",
-                        debugstr_w(filename), sec[i].Name, ptr + sec[i].VirtualAddress,
+                        logfd != 2 && path_of_fd(fd, fd_path, sizeof(fd_path)) > 0 ? fd_path : debugstr_w(filename), sec[i].Name, ptr + sec[i].VirtualAddress,
                         (int)sec[i].PointerToRawData, (int)sec[i].SizeOfRawData,
                         (int)sec[i].Misc.VirtualSize, (int)sec[i].Characteristics );
 
         if (!sec[i].PointerToRawData || !file_size) continue;
 
         /* Note: if the section is not aligned properly map_file_into_view will magically
          *       fall back to read(), so we don't need to check anything here.
          */
         end = file_start + file_size;
         if (sec[i].PointerToRawData >= st.st_size ||
             end > ((st.st_size + sector_align) & ~sector_align) ||
             end < file_start ||
             map_file_into_view( view, fd, sec[i].VirtualAddress, file_size, file_start,
                                 VPROT_COMMITTED | VPROT_READ | VPROT_WRITECOPY,
                                 removable ) != STATUS_SUCCESS)
         {
             ERR_(module)( "Could not map %s section %.8s, file probably truncated\n",
                           debugstr_w(filename), sec[i].Name );
             goto done;
         }
@@ -4242,40 +4270,41 @@ void *virtual_setup_exception( void *stack_ptr, size_t size, EXCEPTION_RECORD *r
     {
         if (is_inside_signal_stack( stack ))
         {
             ERR( "nested exception on signal stack addr %p stack %p\n", rec->ExceptionAddress, stack );
             abort_thread(1);
         }
         WARN( "exception outside of stack limits addr %p stack %p (%p-%p-%p)\n",
               rec->ExceptionAddress, stack, NtCurrentTeb()->DeallocationStack,
               NtCurrentTeb()->Tib.StackLimit, NtCurrentTeb()->Tib.StackBase );
         return stack - size;
     }
 
     stack -= size;
 
     if (stack < stack_info.start + host_page_size)
     {
         /* stack overflow on last page, unrecoverable */
         UINT diff = stack_info.start + host_page_size - stack;
         ERR( "stack overflow %u bytes addr %p stack %p (%p-%p-%p)\n",
              diff, rec->ExceptionAddress, stack, stack_info.start, stack_info.limit, stack_info.end );
+
         abort_thread(1);
     }
     else if (stack < stack_info.limit)
     {
         char *page = ROUND_ADDR( stack, host_page_mask );
         mutex_lock( &virtual_mutex );  /* no need for signal masking inside signal handler */
         if ((get_host_page_vprot( page ) & VPROT_GUARD) && grow_thread_stack( page, &stack_info ))
         {
             rec->ExceptionCode = STATUS_STACK_OVERFLOW;
             rec->NumberParameters = 0;
         }
         mutex_unlock( &virtual_mutex );
     }
 #if defined(VALGRIND_MAKE_MEM_UNDEFINED)
     VALGRIND_MAKE_MEM_UNDEFINED( stack, size );
 #elif defined(VALGRIND_MAKE_WRITABLE)
     VALGRIND_MAKE_WRITABLE( stack, size );
 #endif
     return stack;
 }
