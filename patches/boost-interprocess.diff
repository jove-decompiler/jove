diff --git a/include/boost/interprocess/detail/file_wrapper.hpp b/include/boost/interprocess/detail/file_wrapper.hpp
index dc2fc7c..bbcc94f 100644
--- a/include/boost/interprocess/detail/file_wrapper.hpp
+++ b/include/boost/interprocess/detail/file_wrapper.hpp
@@ -125,42 +125,43 @@ class file_wrapper
 
    //!Returns the name of the file
    //!used in the constructor
    bool get_size(offset_t &size) const;
 
    //!Returns access mode
    //!used in the constructor
    mode_t get_mode() const;
 
    //!Get mapping handle
    //!to use with mapped_region
    mapping_handle_t get_mapping_handle() const;
 
    private:
    //!Closes a previously opened file mapping. Never throws.
    void priv_close();
    //!Closes a previously opened file mapping. Never throws.
    template <class CharT>
    bool priv_open_or_create(ipcdetail::create_enum_t type, const CharT *filename, mode_t mode, const permissions &perm);
 
+   public:
    file_handle_t  m_handle;
-   mode_t         m_mode;
+   mode_t         m_mode = (mode_t)0;
 };
 
 inline file_wrapper::file_wrapper()
    : m_handle(file_handle_t(ipcdetail::invalid_file()))
    , m_mode(read_only)
 {}
 
 inline file_wrapper::~file_wrapper()
 {  this->priv_close(); }
 
 inline bool file_wrapper::get_size(offset_t &size) const
 {  return get_file_size((file_handle_t)m_handle, size);  }
 
 inline void file_wrapper::swap(file_wrapper &other)
 {
    (simple_swap)(m_handle,  other.m_handle);
    (simple_swap)(m_mode,    other.m_mode);
 }
 
 inline mapping_handle_t file_wrapper::get_mapping_handle() const
diff --git a/include/boost/interprocess/detail/os_file_functions.hpp b/include/boost/interprocess/detail/os_file_functions.hpp
index 137409d..0c5460c 100644
--- a/include/boost/interprocess/detail/os_file_functions.hpp
+++ b/include/boost/interprocess/detail/os_file_functions.hpp
@@ -533,79 +533,79 @@ inline bool open_or_create_shared_directory(const char *path)
 }
 
 inline bool remove_directory(const char *path)
 {  return ::rmdir(path) == 0; }
 
 inline bool get_temporary_path(char *buffer, std::size_t buf_len, std::size_t &required_len)
 {
    required_len = 5u;
    if(buf_len < required_len)
       return false;
    else{
       std::strcpy(buffer, "/tmp");
    }
    return true;
 }
 
 inline file_handle_t create_new_file
    (const char *name, mode_t mode, const permissions & perm = permissions(), bool temporary = false)
 {
    (void)temporary;
-   int ret = BOOST_INTERPROCESS_EINTR_RETRY(int, -1, ::open(name, ((int)mode) | O_EXCL | O_CREAT, perm.get_permissions()));
+   int ret = BOOST_INTERPROCESS_EINTR_RETRY(int, -1, ::open(name, ((int)mode) | O_EXCL | O_CREAT | O_CLOEXEC, perm.get_permissions()));
    if(ret >= 0){
       int rc = BOOST_INTERPROCESS_EINTR_RETRY(int, -1, ::fchmod(ret, perm.get_permissions()));
       (void)rc;
    }
    return ret;
 }
 
 inline file_handle_t create_or_open_file
    (const char *name, mode_t mode, const permissions & perm = permissions(), bool temporary = false)
 {
    (void)temporary;
    int ret = -1;
    //We need a loop to change permissions correctly using fchmod, since
    //with "O_CREAT only" ::open we don't know if we've created or opened the file.
    while(true){
-      ret = BOOST_INTERPROCESS_EINTR_RETRY(int, -1, ::open(name, ((int)mode) | O_EXCL | O_CREAT, perm.get_permissions()));
+      ret = BOOST_INTERPROCESS_EINTR_RETRY(int, -1, ::open(name, ((int)mode) | O_EXCL | O_CREAT | O_CLOEXEC, perm.get_permissions()));
       if(ret >= 0){
          int rc = BOOST_INTERPROCESS_EINTR_RETRY(int, -1, ::fchmod(ret, perm.get_permissions()));
          (void)rc;
          break;
       }
       else if(errno == EEXIST){
-         if((ret = BOOST_INTERPROCESS_EINTR_RETRY(int, -1, ::open(name, (int)mode))) >= 0 || errno != ENOENT){
+         if((ret = BOOST_INTERPROCESS_EINTR_RETRY(int, -1, ::open(name, (int)mode | O_CLOEXEC))) >= 0 || errno != ENOENT){
             break;
          }
       }
       else{
          break;
       }
    }
    return ret;
 }
 
 inline file_handle_t open_existing_file
    (const char *name, mode_t mode, bool temporary = false)
 {
    (void)temporary;
-   return BOOST_INTERPROCESS_EINTR_RETRY(int, -1, ::open(name, (int)mode));
+   return BOOST_INTERPROCESS_EINTR_RETRY(int, -1, ::open(name, (int)mode | O_CLOEXEC));
 }
 
 inline bool delete_file(const char *name)
 {  return BOOST_INTERPROCESS_EINTR_RETRY(int, -1, ::unlink(name)) == 0;   }
 
 inline bool truncate_file (file_handle_t hnd, std::size_t size)
 {
    typedef boost::move_detail::make_unsigned<off_t>::type uoff_t;
    BOOST_INTERPROCESS_STATIC_ASSERT(( sizeof(uoff_t) >= sizeof(std::size_t) ));
    if( uoff_t(-1)/2u < uoff_t(size) ){
       errno = EINVAL;
       return false;
    }
    return 0 == BOOST_INTERPROCESS_EINTR_RETRY(int, -1, ::ftruncate(hnd, off_t(size)));
 }
 
 inline bool get_file_size(file_handle_t hnd, offset_t &size)
 {
    struct stat data;
    bool ret = 0 == BOOST_INTERPROCESS_EINTR_RETRY(int, -1, ::fstat(hnd, &data));
diff --git a/include/boost/interprocess/managed_mapped_file.hpp b/include/boost/interprocess/managed_mapped_file.hpp
index 3c4570c..4117d6b 100644
--- a/include/boost/interprocess/managed_mapped_file.hpp
+++ b/include/boost/interprocess/managed_mapped_file.hpp
@@ -43,41 +43,41 @@ template
          class CharType,
          class AllocationAlgorithm,
          template<class IndexConfig> class IndexType
       >
 struct mfile_open_or_create
 {
    static const std::size_t segment_manager_alignment = boost::move_detail::alignment_of
          < segment_manager
                < CharType
                , AllocationAlgorithm
                , IndexType>
          >::value;
    static const std::size_t final_segment_manager_alignment
       = segment_manager_alignment > AllocationAlgorithm::Alignment
       ? segment_manager_alignment : AllocationAlgorithm::Alignment;
 
    typedef  ipcdetail::managed_open_or_create_impl
       < file_wrapper
       , final_segment_manager_alignment
       , true
-      , false> type;
+      , true> type;
 };
 
 }  //namespace ipcdetail {
 
 //!A basic mapped file named object creation class. Initializes the
 //!mapped file. Inherits all basic functionality from
 //!basic_managed_memory_impl<CharType, AllocationAlgorithm, IndexType>
 template
       <
          class CharType,
          class AllocationAlgorithm,
          template<class IndexConfig> class IndexType
       >
 class basic_managed_mapped_file
    #if !defined(BOOST_INTERPROCESS_DOXYGEN_INVOKED)
    : public ipcdetail::basic_managed_memory_impl
       < CharType, AllocationAlgorithm, IndexType
       , ipcdetail::mfile_open_or_create
          <CharType, AllocationAlgorithm, IndexType>::type::ManagedOpenOrCreateUserOffset>
    #endif   //#ifndef BOOST_INTERPROCESS_DOXYGEN_INVOKED
@@ -322,41 +322,41 @@ class basic_managed_mapped_file
    }
 
    #endif
 
    #if !defined(BOOST_INTERPROCESS_DOXYGEN_INVOKED)
 
    //!Tries to find a previous named allocation address. Returns a memory
    //!buffer and the object count. If not found returned pointer is 0.
    //!Never throws.
    template <class T>
    std::pair<T*, size_type> find  (char_ptr_holder_t name)
    {
       if(m_mfile.get_mapped_region().get_mode() == read_only){
          return base_t::template find_no_lock<T>(name);
       }
       else{
          return base_t::template find<T>(name);
       }
    }
 
-   private:
+   public:
    typename ipcdetail::mfile_open_or_create
       <CharType, AllocationAlgorithm, IndexType>::type m_mfile;
    #endif   //#ifndef BOOST_INTERPROCESS_DOXYGEN_INVOKED
 };
 
 #ifdef BOOST_INTERPROCESS_DOXYGEN_INVOKED
 
 //!Typedef for a default basic_managed_mapped_file
 //!of narrow characters
 typedef basic_managed_mapped_file
    <char
    ,rbtree_best_fit<mutex_family>
    ,iset_index>
 managed_mapped_file;
 
 //!Typedef for a default basic_managed_mapped_file
 //!of wide characters
 typedef basic_managed_mapped_file
    <wchar_t
    ,rbtree_best_fit<mutex_family>
diff --git a/include/boost/interprocess/mapped_region.hpp b/include/boost/interprocess/mapped_region.hpp
index b410de4..58cf7d4 100644
--- a/include/boost/interprocess/mapped_region.hpp
+++ b/include/boost/interprocess/mapped_region.hpp
@@ -647,43 +647,49 @@ inline mapped_region::mapped_region
 
    //We calculate the difference between demanded and valid offset
    const offset_t page_offset = priv_page_offset_addr_fixup(offset, address);
 
    if(size == 0){
       struct ::stat buf;
       if(0 != fstat(map_hnd.handle, &buf)){
          error_info err(system_error_code());
          throw interprocess_exception(err);
       }
       //This can throw
       priv_size_from_mapping_size(buf.st_size, offset, page_offset, size);
    }
 
    #ifdef MAP_NOSYNC
       #define BOOST_INTERPROCESS_MAP_NOSYNC MAP_NOSYNC
    #else
       #define BOOST_INTERPROCESS_MAP_NOSYNC 0
    #endif   //MAP_NOSYNC
 
+   #ifdef MAP_NORESERVE
+      #define BOOST_INTERPROCESS_MAP_NORESERVE MAP_NORESERVE
+   #else
+      #define BOOST_INTERPROCESS_MAP_NORESERVE 0
+   #endif   //MAP_NORESERVE
+
    //Create new mapping
    int prot    = 0;
-   int flags   = map_options == default_map_options ? BOOST_INTERPROCESS_MAP_NOSYNC : map_options;
+   int flags   = map_options == default_map_options ? (BOOST_INTERPROCESS_MAP_NORESERVE | BOOST_INTERPROCESS_MAP_NOSYNC) : map_options;
 
    #undef BOOST_INTERPROCESS_MAP_NOSYNC
 
    switch(mode)
    {
       case read_only:
          prot  |= PROT_READ;
          flags |= MAP_SHARED;
       break;
 
       case read_private:
          prot  |= (PROT_READ);
          flags |= MAP_PRIVATE;
       break;
 
       case read_write:
          prot  |= (PROT_WRITE | PROT_READ);
          flags |= MAP_SHARED;
       break;
 
