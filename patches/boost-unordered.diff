diff --git a/include/boost/unordered/concurrent_flat_map.hpp b/include/boost/unordered/concurrent_flat_map.hpp
index 77445d18..b29afd3f 100644
--- a/include/boost/unordered/concurrent_flat_map.hpp
+++ b/include/boost/unordered/concurrent_flat_map.hpp
@@ -10,69 +10,69 @@
  */
 
 #ifndef BOOST_UNORDERED_CONCURRENT_FLAT_MAP_HPP
 #define BOOST_UNORDERED_CONCURRENT_FLAT_MAP_HPP
 
 #include <boost/unordered/concurrent_flat_map_fwd.hpp>
 #include <boost/unordered/detail/concurrent_static_asserts.hpp>
 #include <boost/unordered/detail/foa/concurrent_table.hpp>
 #include <boost/unordered/detail/foa/flat_map_types.hpp>
 #include <boost/unordered/detail/type_traits.hpp>
 #include <boost/unordered/unordered_flat_map_fwd.hpp>
 
 #include <boost/container_hash/hash.hpp>
 #include <boost/core/allocator_access.hpp>
 #include <boost/core/serialization.hpp>
 
 #include <type_traits>
 
 namespace boost {
   namespace unordered {
-    template <class Key, class T, class Hash, class Pred, class Allocator>
+    template <class Key, class T, class Hash, class Pred, class Allocator, class Spin>
     class concurrent_flat_map
     {
     private:
       template <class Key2, class T2, class Hash2, class Pred2,
-        class Allocator2>
+        class Allocator2, class Spin2>
       friend class concurrent_flat_map;
       template <class Key2, class T2, class Hash2, class Pred2,
         class Allocator2>
       friend class unordered_flat_map;
 
       using type_policy = detail::foa::flat_map_types<Key, T>;
 
       using table_type =
-        detail::foa::concurrent_table<type_policy, Hash, Pred, Allocator>;
+        detail::foa::concurrent_table<type_policy, Hash, Pred, Allocator, Spin>;
 
       table_type table_;
 
-      template <class K, class V, class H, class KE, class A>
-      bool friend operator==(concurrent_flat_map<K, V, H, KE, A> const& lhs,
-        concurrent_flat_map<K, V, H, KE, A> const& rhs);
+      template <class K, class V, class H, class KE, class A, class S>
+      bool friend operator==(concurrent_flat_map<K, V, H, KE, A, S> const& lhs,
+        concurrent_flat_map<K, V, H, KE, A, S> const& rhs);
 
-      template <class K, class V, class H, class KE, class A, class Predicate>
-      friend typename concurrent_flat_map<K, V, H, KE, A>::size_type erase_if(
-        concurrent_flat_map<K, V, H, KE, A>& set, Predicate pred);
+      template <class K, class V, class H, class KE, class A, class S, class Predicate>
+      friend typename concurrent_flat_map<K, V, H, KE, A, S>::size_type erase_if(
+        concurrent_flat_map<K, V, H, KE, A, S>& set, Predicate pred);
 
-      template<class Archive, class K, class V, class H, class KE, class A>
+      template<class Archive, class K, class V, class H, class KE, class A, class S>
       friend void serialize(
-        Archive& ar, concurrent_flat_map<K, V, H, KE, A>& c,
+        Archive& ar, concurrent_flat_map<K, V, H, KE, A, S>& c,
         unsigned int version);
 
     public:
       using key_type = Key;
       using mapped_type = T;
       using value_type = typename type_policy::value_type;
       using init_type = typename type_policy::init_type;
       using size_type = std::size_t;
       using difference_type = std::ptrdiff_t;
       using hasher = typename boost::unordered::detail::type_identity<Hash>::type;
       using key_equal = typename boost::unordered::detail::type_identity<Pred>::type;
       using allocator_type = typename boost::unordered::detail::type_identity<Allocator>::type;
       using reference = value_type&;
       using const_reference = value_type const&;
       using pointer = typename boost::allocator_pointer<allocator_type>::type;
       using const_pointer =
         typename boost::allocator_const_pointer<allocator_type>::type;
       static constexpr size_type bulk_visit_size = table_type::bulk_visit_size;
 
 #if defined(BOOST_UNORDERED_ENABLE_STATS)
@@ -903,153 +903,163 @@ namespace boost {
 
 #if defined(BOOST_UNORDERED_ENABLE_STATS)
       /// Stats
       ///
       stats get_stats() const { return table_.get_stats(); }
 
       void reset_stats() noexcept { table_.reset_stats(); }
 #endif
 
       /// Observers
       ///
       allocator_type get_allocator() const noexcept
       {
         return table_.get_allocator();
       }
 
       hasher hash_function() const { return table_.hash_function(); }
       key_equal key_eq() const { return table_.key_eq(); }
     };
 
-    template <class Key, class T, class Hash, class KeyEqual, class Allocator>
+    template <class Key, class T, class Hash, class KeyEqual, class Allocator, class Spin>
     bool operator==(
-      concurrent_flat_map<Key, T, Hash, KeyEqual, Allocator> const& lhs,
-      concurrent_flat_map<Key, T, Hash, KeyEqual, Allocator> const& rhs)
+      concurrent_flat_map<Key, T, Hash, KeyEqual, Allocator, Spin> const& lhs,
+      concurrent_flat_map<Key, T, Hash, KeyEqual, Allocator, Spin> const& rhs)
     {
       return lhs.table_ == rhs.table_;
     }
 
-    template <class Key, class T, class Hash, class KeyEqual, class Allocator>
+    template <class Key, class T, class Hash, class KeyEqual, class Allocator, class Spin>
     bool operator!=(
-      concurrent_flat_map<Key, T, Hash, KeyEqual, Allocator> const& lhs,
-      concurrent_flat_map<Key, T, Hash, KeyEqual, Allocator> const& rhs)
+      concurrent_flat_map<Key, T, Hash, KeyEqual, Allocator, Spin> const& lhs,
+      concurrent_flat_map<Key, T, Hash, KeyEqual, Allocator, Spin> const& rhs)
     {
       return !(lhs == rhs);
     }
 
-    template <class Key, class T, class Hash, class Pred, class Alloc>
-    void swap(concurrent_flat_map<Key, T, Hash, Pred, Alloc>& x,
+    template <class Key, class T, class Hash, class Pred, class Alloc, class Spin>
+    void swap(concurrent_flat_map<Key, T, Hash, Pred, Alloc, Spin>& x,
       concurrent_flat_map<Key, T, Hash, Pred, Alloc>& y)
       noexcept(noexcept(x.swap(y)))
     {
       x.swap(y);
     }
 
-    template <class K, class T, class H, class P, class A, class Predicate>
-    typename concurrent_flat_map<K, T, H, P, A>::size_type erase_if(
-      concurrent_flat_map<K, T, H, P, A>& c, Predicate pred)
+    template <class K, class T, class H, class P, class A, class S, class Predicate>
+    typename concurrent_flat_map<K, T, H, P, A, S>::size_type erase_if(
+      concurrent_flat_map<K, T, H, P, A, S>& c, Predicate pred)
     {
       return c.table_.erase_if(pred);
     }
 
-    template<class Archive, class K, class V, class H, class KE, class A>
+    template<class Archive, class K, class V, class H, class KE, class A, class S>
     void serialize(
-      Archive& ar, concurrent_flat_map<K, V, H, KE, A>& c, unsigned int)
+      Archive& ar, concurrent_flat_map<K, V, H, KE, A, S>& c, unsigned int)
     {
       ar & core::make_nvp("table",c.table_);
     }
 
 #if BOOST_UNORDERED_TEMPLATE_DEDUCTION_GUIDES
 
     template <class InputIterator,
       class Hash =
         boost::hash<boost::unordered::detail::iter_key_t<InputIterator> >,
       class Pred =
         std::equal_to<boost::unordered::detail::iter_key_t<InputIterator> >,
       class Allocator = std::allocator<
         boost::unordered::detail::iter_to_alloc_t<InputIterator> >,
+      class Spin,
       class = std::enable_if_t<detail::is_input_iterator_v<InputIterator> >,
       class = std::enable_if_t<detail::is_hash_v<Hash> >,
       class = std::enable_if_t<detail::is_pred_v<Pred> >,
-      class = std::enable_if_t<detail::is_allocator_v<Allocator> > >
+      class = std::enable_if_t<detail::is_allocator_v<Allocator> >,
+      class = std::enable_if_t<detail::is_true_or_false_type_v<Spin> > >
     concurrent_flat_map(InputIterator, InputIterator,
       std::size_t = boost::unordered::detail::foa::default_bucket_count,
-      Hash = Hash(), Pred = Pred(), Allocator = Allocator())
+      Hash = Hash(), Pred = Pred(), Allocator = Allocator(), Spin = Spin())
       -> concurrent_flat_map<
         boost::unordered::detail::iter_key_t<InputIterator>,
         boost::unordered::detail::iter_val_t<InputIterator>, Hash, Pred,
-        Allocator>;
+        Allocator, Spin>;
 
     template <class Key, class T,
       class Hash = boost::hash<std::remove_const_t<Key> >,
       class Pred = std::equal_to<std::remove_const_t<Key> >,
       class Allocator = std::allocator<std::pair<const Key, T> >,
+      class Spin,
       class = std::enable_if_t<detail::is_hash_v<Hash> >,
       class = std::enable_if_t<detail::is_pred_v<Pred> >,
-      class = std::enable_if_t<detail::is_allocator_v<Allocator> > >
+      class = std::enable_if_t<detail::is_allocator_v<Allocator> >,
+      class = std::enable_if_t<detail::is_true_or_false_type_v<Spin> > >
     concurrent_flat_map(std::initializer_list<std::pair<Key, T> >,
       std::size_t = boost::unordered::detail::foa::default_bucket_count,
-      Hash = Hash(), Pred = Pred(), Allocator = Allocator())
+      Hash = Hash(), Pred = Pred(), Allocator = Allocator(), Spin = Spin())
       -> concurrent_flat_map<std::remove_const_t<Key>, T, Hash, Pred,
-        Allocator>;
+        Allocator, Spin>;
 
-    template <class InputIterator, class Allocator,
+    template <class InputIterator, class Allocator, class Spin,
       class = std::enable_if_t<detail::is_input_iterator_v<InputIterator> >,
-      class = std::enable_if_t<detail::is_allocator_v<Allocator> > >
-    concurrent_flat_map(InputIterator, InputIterator, std::size_t, Allocator)
+      class = std::enable_if_t<detail::is_allocator_v<Allocator> >,
+      class = std::enable_if_t<detail::is_true_or_false_type_v<Spin> > >
+    concurrent_flat_map(InputIterator, InputIterator, std::size_t, Allocator, Spin)
       -> concurrent_flat_map<
         boost::unordered::detail::iter_key_t<InputIterator>,
         boost::unordered::detail::iter_val_t<InputIterator>,
         boost::hash<boost::unordered::detail::iter_key_t<InputIterator> >,
         std::equal_to<boost::unordered::detail::iter_key_t<InputIterator> >,
-        Allocator>;
+        Allocator, Spin>;
 
-    template <class InputIterator, class Allocator,
+    template <class InputIterator, class Allocator, class Spin,
       class = std::enable_if_t<detail::is_input_iterator_v<InputIterator> >,
-      class = std::enable_if_t<detail::is_allocator_v<Allocator> > >
-    concurrent_flat_map(InputIterator, InputIterator, Allocator)
+      class = std::enable_if_t<detail::is_allocator_v<Allocator> >,
+      class = std::enable_if_t<detail::is_true_or_false_type_v<Spin> > >
+    concurrent_flat_map(InputIterator, InputIterator, Allocator, Spin)
       -> concurrent_flat_map<
         boost::unordered::detail::iter_key_t<InputIterator>,
         boost::unordered::detail::iter_val_t<InputIterator>,
         boost::hash<boost::unordered::detail::iter_key_t<InputIterator> >,
         std::equal_to<boost::unordered::detail::iter_key_t<InputIterator> >,
-        Allocator>;
+        Allocator, Spin>;
 
-    template <class InputIterator, class Hash, class Allocator,
+    template <class InputIterator, class Hash, class Allocator, class Spin,
       class = std::enable_if_t<detail::is_hash_v<Hash> >,
       class = std::enable_if_t<detail::is_input_iterator_v<InputIterator> >,
-      class = std::enable_if_t<detail::is_allocator_v<Allocator> > >
+      class = std::enable_if_t<detail::is_allocator_v<Allocator> >,
+      class = std::enable_if_t<detail::is_true_or_false_type_v<Spin> > >
     concurrent_flat_map(
-      InputIterator, InputIterator, std::size_t, Hash, Allocator)
+      InputIterator, InputIterator, std::size_t, Hash, Allocator, Spin)
       -> concurrent_flat_map<
         boost::unordered::detail::iter_key_t<InputIterator>,
         boost::unordered::detail::iter_val_t<InputIterator>, Hash,
         std::equal_to<boost::unordered::detail::iter_key_t<InputIterator> >,
-        Allocator>;
+        Allocator, Spin>;
 
-    template <class Key, class T, class Allocator,
-      class = std::enable_if_t<detail::is_allocator_v<Allocator> > >
+    template <class Key, class T, class Allocator, class Spin,
+      class = std::enable_if_t<detail::is_allocator_v<Allocator> >,
+      class = std::enable_if_t<detail::is_true_or_false_type_v<Spin> > >
     concurrent_flat_map(std::initializer_list<std::pair<Key, T> >, std::size_t,
-      Allocator) -> concurrent_flat_map<std::remove_const_t<Key>, T,
+      Allocator, Spin) -> concurrent_flat_map<std::remove_const_t<Key>, T,
       boost::hash<std::remove_const_t<Key> >,
-      std::equal_to<std::remove_const_t<Key> >, Allocator>;
+      std::equal_to<std::remove_const_t<Key> >, Allocator, Spin>;
 
-    template <class Key, class T, class Allocator,
-      class = std::enable_if_t<detail::is_allocator_v<Allocator> > >
-    concurrent_flat_map(std::initializer_list<std::pair<Key, T> >, Allocator)
+    template <class Key, class T, class Allocator, class Spin,
+      class = std::enable_if_t<detail::is_allocator_v<Allocator> >,
+      class = std::enable_if_t<detail::is_true_or_false_type_v<Spin> > >
+    concurrent_flat_map(std::initializer_list<std::pair<Key, T> >, Allocator, Spin)
       -> concurrent_flat_map<std::remove_const_t<Key>, T,
         boost::hash<std::remove_const_t<Key> >,
-        std::equal_to<std::remove_const_t<Key> >, Allocator>;
+        std::equal_to<std::remove_const_t<Key> >, Allocator, Spin>;
 
-    template <class Key, class T, class Hash, class Allocator,
+    template <class Key, class T, class Hash, class Allocator, class Spin,
       class = std::enable_if_t<detail::is_hash_v<Hash> >,
-      class = std::enable_if_t<detail::is_allocator_v<Allocator> > >
+      class = std::enable_if_t<detail::is_allocator_v<Allocator> >,
+      class = std::enable_if_t<detail::is_true_or_false_type_v<Spin> > >
     concurrent_flat_map(std::initializer_list<std::pair<Key, T> >, std::size_t,
-      Hash, Allocator) -> concurrent_flat_map<std::remove_const_t<Key>, T,
-      Hash, std::equal_to<std::remove_const_t<Key> >, Allocator>;
+      Hash, Allocator, Spin) -> concurrent_flat_map<std::remove_const_t<Key>, T,
+      Hash, std::equal_to<std::remove_const_t<Key> >, Allocator, Spin>;
 
 #endif
 
   } // namespace unordered
 } // namespace boost
 
 #endif // BOOST_UNORDERED_CONCURRENT_FLAT_MAP_HPP
diff --git a/include/boost/unordered/concurrent_flat_map_fwd.hpp b/include/boost/unordered/concurrent_flat_map_fwd.hpp
index e66f3674..9fad5c9b 100644
--- a/include/boost/unordered/concurrent_flat_map_fwd.hpp
+++ b/include/boost/unordered/concurrent_flat_map_fwd.hpp
@@ -10,57 +10,58 @@
  */
 
 #ifndef BOOST_UNORDERED_CONCURRENT_FLAT_MAP_FWD_HPP
 #define BOOST_UNORDERED_CONCURRENT_FLAT_MAP_FWD_HPP
 
 #include <boost/config.hpp>
 #include <boost/container_hash/hash_fwd.hpp>
 
 #include <functional>
 #include <memory>
 
 #ifndef BOOST_NO_CXX17_HDR_MEMORY_RESOURCE
 #include <memory_resource>
 #endif
 
 namespace boost {
   namespace unordered {
 
     template <class Key, class T, class Hash = boost::hash<Key>,
       class Pred = std::equal_to<Key>,
-      class Allocator = std::allocator<std::pair<Key const, T> > >
+      class Allocator = std::allocator<std::pair<Key const, T> >,
+      class Spin = std::true_type>
     class concurrent_flat_map;
 
-    template <class Key, class T, class Hash, class KeyEqual, class Allocator>
+    template <class Key, class T, class Hash, class KeyEqual, class Allocator, class Spin>
     bool operator==(
-      concurrent_flat_map<Key, T, Hash, KeyEqual, Allocator> const& lhs,
-      concurrent_flat_map<Key, T, Hash, KeyEqual, Allocator> const& rhs);
+      concurrent_flat_map<Key, T, Hash, KeyEqual, Allocator, Spin> const& lhs,
+      concurrent_flat_map<Key, T, Hash, KeyEqual, Allocator, Spin> const& rhs);
 
-    template <class Key, class T, class Hash, class KeyEqual, class Allocator>
+    template <class Key, class T, class Hash, class KeyEqual, class Allocator, class Spin>
     bool operator!=(
-      concurrent_flat_map<Key, T, Hash, KeyEqual, Allocator> const& lhs,
-      concurrent_flat_map<Key, T, Hash, KeyEqual, Allocator> const& rhs);
+      concurrent_flat_map<Key, T, Hash, KeyEqual, Allocator, Spin> const& lhs,
+      concurrent_flat_map<Key, T, Hash, KeyEqual, Allocator, Spin> const& rhs);
 
-    template <class Key, class T, class Hash, class Pred, class Alloc>
-    void swap(concurrent_flat_map<Key, T, Hash, Pred, Alloc>& x,
-      concurrent_flat_map<Key, T, Hash, Pred, Alloc>& y)
+    template <class Key, class T, class Hash, class Pred, class Alloc, class Spin>
+    void swap(concurrent_flat_map<Key, T, Hash, Pred, Alloc, Spin>& x,
+      concurrent_flat_map<Key, T, Hash, Pred, Alloc, Spin>& y)
       noexcept(noexcept(x.swap(y)));
 
-    template <class K, class T, class H, class P, class A, class Predicate>
-    typename concurrent_flat_map<K, T, H, P, A>::size_type erase_if(
-      concurrent_flat_map<K, T, H, P, A>& c, Predicate pred);
+    template <class K, class T, class H, class P, class A, class S, class Predicate>
+    typename concurrent_flat_map<K, T, H, P, A, S>::size_type erase_if(
+      concurrent_flat_map<K, T, H, P, A, S>& c, Predicate pred);
 
 #ifndef BOOST_NO_CXX17_HDR_MEMORY_RESOURCE
     namespace pmr {
       template <class Key, class T, class Hash = boost::hash<Key>,
         class Pred = std::equal_to<Key> >
       using concurrent_flat_map = boost::unordered::concurrent_flat_map<Key, T,
         Hash, Pred, std::pmr::polymorphic_allocator<std::pair<Key const, T> > >;
     } // namespace pmr
 #endif
 
   } // namespace unordered
 
   using boost::unordered::concurrent_flat_map;
 } // namespace boost
 
 #endif // BOOST_UNORDERED_CONCURRENT_FLAT_MAP_HPP
diff --git a/include/boost/unordered/concurrent_flat_set.hpp b/include/boost/unordered/concurrent_flat_set.hpp
index f0f44308..d73f137c 100644
--- a/include/boost/unordered/concurrent_flat_set.hpp
+++ b/include/boost/unordered/concurrent_flat_set.hpp
@@ -10,67 +10,67 @@
  */
 
 #ifndef BOOST_UNORDERED_CONCURRENT_FLAT_SET_HPP
 #define BOOST_UNORDERED_CONCURRENT_FLAT_SET_HPP
 
 #include <boost/unordered/concurrent_flat_set_fwd.hpp>
 #include <boost/unordered/detail/concurrent_static_asserts.hpp>
 #include <boost/unordered/detail/foa/concurrent_table.hpp>
 #include <boost/unordered/detail/foa/flat_set_types.hpp>
 #include <boost/unordered/detail/type_traits.hpp>
 #include <boost/unordered/unordered_flat_set_fwd.hpp>
 
 #include <boost/container_hash/hash.hpp>
 #include <boost/core/allocator_access.hpp>
 #include <boost/core/serialization.hpp>
 
 #include <utility>
 
 namespace boost {
   namespace unordered {
-    template <class Key, class Hash, class Pred, class Allocator>
+    template <class Key, class Hash, class Pred, class Allocator, class Spin>
     class concurrent_flat_set
     {
     private:
-      template <class Key2, class Hash2, class Pred2, class Allocator2>
+      template <class Key2, class Hash2, class Pred2, class Allocator2, class Spin2>
       friend class concurrent_flat_set;
       template <class Key2, class Hash2, class Pred2, class Allocator2>
       friend class unordered_flat_set;
 
       using type_policy = detail::foa::flat_set_types<Key>;
 
       using table_type =
-        detail::foa::concurrent_table<type_policy, Hash, Pred, Allocator>;
+        detail::foa::concurrent_table<type_policy, Hash, Pred, Allocator, Spin>;
 
       table_type table_;
 
-      template <class K, class H, class KE, class A>
-      bool friend operator==(concurrent_flat_set<K, H, KE, A> const& lhs,
-        concurrent_flat_set<K, H, KE, A> const& rhs);
+      template <class K, class H, class KE, class A, class S>
+      bool friend operator==(concurrent_flat_set<K, H, KE, A, S> const& lhs,
+        concurrent_flat_set<K, H, KE, A, S> const& rhs);
 
-      template <class K, class H, class KE, class A, class Predicate>
-      friend typename concurrent_flat_set<K, H, KE, A>::size_type erase_if(
-        concurrent_flat_set<K, H, KE, A>& set, Predicate pred);
+      template <class K, class H, class KE, class A, class S, class Predicate>
+      friend typename concurrent_flat_set<K, H, KE, A, S>::size_type erase_if(
+        concurrent_flat_set<K, H, KE, A, S>& set, Predicate pred);
 
-      template<class Archive, class K, class H, class KE, class A>
+      template<class Archive, class K, class H, class KE, class A, class S>
       friend void serialize(
-        Archive& ar, concurrent_flat_set<K, H, KE, A>& c,
+        Archive& ar, concurrent_flat_set<K, H, KE, A, S>& c,
         unsigned int version);
 
     public:
       using key_type = Key;
       using value_type = typename type_policy::value_type;
       using init_type = typename type_policy::init_type;
       using size_type = std::size_t;
       using difference_type = std::ptrdiff_t;
       using hasher = typename boost::unordered::detail::type_identity<Hash>::type;
       using key_equal = typename boost::unordered::detail::type_identity<Pred>::type;
       using allocator_type = typename boost::unordered::detail::type_identity<Allocator>::type;
       using reference = value_type&;
       using const_reference = value_type const&;
       using pointer = typename boost::allocator_pointer<allocator_type>::type;
       using const_pointer =
         typename boost::allocator_const_pointer<allocator_type>::type;
       static constexpr size_type bulk_visit_size = table_type::bulk_visit_size;
 
 #if defined(BOOST_UNORDERED_ENABLE_STATS)
       using stats = typename table_type::stats;
@@ -777,141 +777,151 @@ namespace boost {
 
 #if defined(BOOST_UNORDERED_ENABLE_STATS)
       /// Stats
       ///
       stats get_stats() const { return table_.get_stats(); }
 
       void reset_stats() noexcept { table_.reset_stats(); }
 #endif
 
       /// Observers
       ///
       allocator_type get_allocator() const noexcept
       {
         return table_.get_allocator();
       }
 
       hasher hash_function() const { return table_.hash_function(); }
       key_equal key_eq() const { return table_.key_eq(); }
     };
 
-    template <class Key, class Hash, class KeyEqual, class Allocator>
+    template <class Key, class Hash, class KeyEqual, class Allocator, class Spin>
     bool operator==(
-      concurrent_flat_set<Key, Hash, KeyEqual, Allocator> const& lhs,
-      concurrent_flat_set<Key, Hash, KeyEqual, Allocator> const& rhs)
+      concurrent_flat_set<Key, Hash, KeyEqual, Allocator, Spin> const& lhs,
+      concurrent_flat_set<Key, Hash, KeyEqual, Allocator, Spin> const& rhs)
     {
       return lhs.table_ == rhs.table_;
     }
 
-    template <class Key, class Hash, class KeyEqual, class Allocator>
+    template <class Key, class Hash, class KeyEqual, class Allocator, class Spin>
     bool operator!=(
-      concurrent_flat_set<Key, Hash, KeyEqual, Allocator> const& lhs,
-      concurrent_flat_set<Key, Hash, KeyEqual, Allocator> const& rhs)
+      concurrent_flat_set<Key, Hash, KeyEqual, Allocator, Spin> const& lhs,
+      concurrent_flat_set<Key, Hash, KeyEqual, Allocator, Spin> const& rhs)
     {
       return !(lhs == rhs);
     }
 
-    template <class Key, class Hash, class Pred, class Alloc>
-    void swap(concurrent_flat_set<Key, Hash, Pred, Alloc>& x,
-      concurrent_flat_set<Key, Hash, Pred, Alloc>& y)
+    template <class Key, class Hash, class Pred, class Alloc, class Spin>
+    void swap(concurrent_flat_set<Key, Hash, Pred, Alloc, Spin>& x,
+      concurrent_flat_set<Key, Hash, Pred, Alloc, Spin>& y)
       noexcept(noexcept(x.swap(y)))
     {
       x.swap(y);
     }
 
-    template <class K, class H, class P, class A, class Predicate>
-    typename concurrent_flat_set<K, H, P, A>::size_type erase_if(
-      concurrent_flat_set<K, H, P, A>& c, Predicate pred)
+    template <class K, class H, class P, class A, class S, class Predicate>
+    typename concurrent_flat_set<K, H, P, A, S>::size_type erase_if(
+      concurrent_flat_set<K, H, P, A, S>& c, Predicate pred)
     {
       return c.table_.erase_if(pred);
     }
 
-    template<class Archive, class K, class H, class KE, class A>
+    template<class Archive, class K, class H, class KE, class A, class S>
     void serialize(
-      Archive& ar, concurrent_flat_set<K, H, KE, A>& c, unsigned int)
+      Archive& ar, concurrent_flat_set<K, H, KE, A, S>& c, unsigned int)
     {
       ar & core::make_nvp("table",c.table_);
     }
 
 #if BOOST_UNORDERED_TEMPLATE_DEDUCTION_GUIDES
 
     template <class InputIterator,
       class Hash =
         boost::hash<typename std::iterator_traits<InputIterator>::value_type>,
       class Pred =
         std::equal_to<typename std::iterator_traits<InputIterator>::value_type>,
       class Allocator = std::allocator<
         typename std::iterator_traits<InputIterator>::value_type>,
+      class Spin = std::true_type,
       class = std::enable_if_t<detail::is_input_iterator_v<InputIterator> >,
       class = std::enable_if_t<detail::is_hash_v<Hash> >,
       class = std::enable_if_t<detail::is_pred_v<Pred> >,
-      class = std::enable_if_t<detail::is_allocator_v<Allocator> > >
+      class = std::enable_if_t<detail::is_allocator_v<Allocator> >,
+      class = std::enable_if_t<detail::is_true_or_false_type_v<Spin> > >
     concurrent_flat_set(InputIterator, InputIterator,
       std::size_t = boost::unordered::detail::foa::default_bucket_count,
-      Hash = Hash(), Pred = Pred(), Allocator = Allocator())
+      Hash = Hash(), Pred = Pred(), Allocator = Allocator(), Spin = Spin())
       -> concurrent_flat_set<
         typename std::iterator_traits<InputIterator>::value_type, Hash, Pred,
-        Allocator>;
+        Allocator, Spin>;
 
     template <class T, class Hash = boost::hash<T>,
       class Pred = std::equal_to<T>, class Allocator = std::allocator<T>,
+      class Spin = std::true_type,
       class = std::enable_if_t<detail::is_hash_v<Hash> >,
       class = std::enable_if_t<detail::is_pred_v<Pred> >,
-      class = std::enable_if_t<detail::is_allocator_v<Allocator> > >
+      class = std::enable_if_t<detail::is_allocator_v<Allocator> >,
+      class = std::enable_if_t<detail::is_true_or_false_type_v<Spin> > >
     concurrent_flat_set(std::initializer_list<T>,
       std::size_t = boost::unordered::detail::foa::default_bucket_count,
-      Hash = Hash(), Pred = Pred(), Allocator = Allocator())
-      -> concurrent_flat_set< T, Hash, Pred, Allocator>;
+      Hash = Hash(), Pred = Pred(), Allocator = Allocator(), Spin = Spin())
+      -> concurrent_flat_set< T, Hash, Pred, Allocator, Spin>;
 
-    template <class InputIterator, class Allocator,
+    template <class InputIterator, class Allocator, class Spin,
       class = std::enable_if_t<detail::is_input_iterator_v<InputIterator> >,
-      class = std::enable_if_t<detail::is_allocator_v<Allocator> > >
-    concurrent_flat_set(InputIterator, InputIterator, std::size_t, Allocator)
+      class = std::enable_if_t<detail::is_allocator_v<Allocator> >,
+      class = std::enable_if_t<detail::is_true_or_false_type_v<Spin> > >
+    concurrent_flat_set(InputIterator, InputIterator, std::size_t, Allocator, Spin)
       -> concurrent_flat_set<
         typename std::iterator_traits<InputIterator>::value_type,
         boost::hash<typename std::iterator_traits<InputIterator>::value_type>,
         std::equal_to<typename std::iterator_traits<InputIterator>::value_type>,
-        Allocator>;
+        Allocator, Spin>;
 
-    template <class InputIterator, class Allocator,
+    template <class InputIterator, class Allocator, class Spin,
       class = std::enable_if_t<detail::is_input_iterator_v<InputIterator> >,
-      class = std::enable_if_t<detail::is_allocator_v<Allocator> > >
-    concurrent_flat_set(InputIterator, InputIterator, Allocator)
+      class = std::enable_if_t<detail::is_allocator_v<Allocator> >,
+      class = std::enable_if_t<detail::is_true_or_false_type_v<Spin> > >
+    concurrent_flat_set(InputIterator, InputIterator, Allocator, Spin)
       -> concurrent_flat_set<
         typename std::iterator_traits<InputIterator>::value_type,
         boost::hash<typename std::iterator_traits<InputIterator>::value_type>,
         std::equal_to<typename std::iterator_traits<InputIterator>::value_type>,
-        Allocator>;
+        Allocator, Spin>;
 
-    template <class InputIterator, class Hash, class Allocator,
+    template <class InputIterator, class Hash, class Allocator, class Spin,
       class = std::enable_if_t<detail::is_hash_v<Hash> >,
       class = std::enable_if_t<detail::is_input_iterator_v<InputIterator> >,
-      class = std::enable_if_t<detail::is_allocator_v<Allocator> > >
+      class = std::enable_if_t<detail::is_allocator_v<Allocator> >,
+      class = std::enable_if_t<detail::is_true_or_false_type_v<Spin> > >
     concurrent_flat_set(
-      InputIterator, InputIterator, std::size_t, Hash, Allocator)
+      InputIterator, InputIterator, std::size_t, Hash, Allocator, Spin)
       -> concurrent_flat_set<
         typename std::iterator_traits<InputIterator>::value_type, Hash,
         std::equal_to<typename std::iterator_traits<InputIterator>::value_type>,
-        Allocator>;
+        Allocator, Spin>;
 
-    template <class T, class Allocator,
-      class = std::enable_if_t<detail::is_allocator_v<Allocator> > >
-    concurrent_flat_set(std::initializer_list<T>, std::size_t, Allocator)
-      -> concurrent_flat_set<T, boost::hash<T>,std::equal_to<T>, Allocator>;
+    template <class T, class Allocator, class Spin,
+      class = std::enable_if_t<detail::is_allocator_v<Allocator> >,
+      class = std::enable_if_t<detail::is_true_or_false_type_v<Spin> > >
+    concurrent_flat_set(std::initializer_list<T>, std::size_t, Allocator, Spin)
+      -> concurrent_flat_set<T, boost::hash<T>,std::equal_to<T>, Allocator, Spin>;
 
-    template <class T, class Allocator,
-      class = std::enable_if_t<detail::is_allocator_v<Allocator> > >
-    concurrent_flat_set(std::initializer_list<T >, Allocator)
-      -> concurrent_flat_set<T, boost::hash<T>, std::equal_to<T>, Allocator>;
+    template <class T, class Allocator, class Spin,
+      class = std::enable_if_t<detail::is_allocator_v<Allocator> >,
+      class = std::enable_if_t<detail::is_true_or_false_type_v<Spin> > >
+    concurrent_flat_set(std::initializer_list<T >, Allocator, Spin)
+      -> concurrent_flat_set<T, boost::hash<T>, std::equal_to<T>, Allocator, Spin>;
 
-    template <class T, class Hash, class Allocator,
+    template <class T, class Hash, class Allocator, class Spin,
       class = std::enable_if_t<detail::is_hash_v<Hash> >,
-      class = std::enable_if_t<detail::is_allocator_v<Allocator> > >
-    concurrent_flat_set(std::initializer_list<T >, std::size_t,Hash, Allocator)
-      -> concurrent_flat_set<T, Hash, std::equal_to<T>, Allocator>;
+      class = std::enable_if_t<detail::is_allocator_v<Allocator> >,
+      class = std::enable_if_t<detail::is_true_or_false_type_v<Spin> > >
+    concurrent_flat_set(std::initializer_list<T >, std::size_t,Hash, Allocator, Spin)
+      -> concurrent_flat_set<T, Hash, std::equal_to<T>, Allocator, Spin>;
 
 #endif
 
   } // namespace unordered
 } // namespace boost
 
 #endif // BOOST_UNORDERED_CONCURRENT_FLAT_SET_HPP
diff --git a/include/boost/unordered/concurrent_flat_set_fwd.hpp b/include/boost/unordered/concurrent_flat_set_fwd.hpp
index 1133d9c9..c5088b06 100644
--- a/include/boost/unordered/concurrent_flat_set_fwd.hpp
+++ b/include/boost/unordered/concurrent_flat_set_fwd.hpp
@@ -11,57 +11,58 @@
  */
 
 #ifndef BOOST_UNORDERED_CONCURRENT_FLAT_SET_FWD_HPP
 #define BOOST_UNORDERED_CONCURRENT_FLAT_SET_FWD_HPP
 
 #include <boost/config.hpp>
 #include <boost/container_hash/hash_fwd.hpp>
 
 #include <functional>
 #include <memory>
 
 #ifndef BOOST_NO_CXX17_HDR_MEMORY_RESOURCE
 #include <memory_resource>
 #endif
 
 namespace boost {
   namespace unordered {
 
     template <class Key, class Hash = boost::hash<Key>,
       class Pred = std::equal_to<Key>,
-      class Allocator = std::allocator<Key> >
+      class Allocator = std::allocator<Key>,
+      class Spin = std::true_type>
     class concurrent_flat_set;
 
-    template <class Key, class Hash, class KeyEqual, class Allocator>
+    template <class Key, class Hash, class KeyEqual, class Allocator, class Spin>
     bool operator==(
-      concurrent_flat_set<Key, Hash, KeyEqual, Allocator> const& lhs,
-      concurrent_flat_set<Key, Hash, KeyEqual, Allocator> const& rhs);
+      concurrent_flat_set<Key, Hash, KeyEqual, Allocator, Spin> const& lhs,
+      concurrent_flat_set<Key, Hash, KeyEqual, Allocator, Spin> const& rhs);
 
-    template <class Key, class Hash, class KeyEqual, class Allocator>
+    template <class Key, class Hash, class KeyEqual, class Allocator, class Spin>
     bool operator!=(
-      concurrent_flat_set<Key, Hash, KeyEqual, Allocator> const& lhs,
-      concurrent_flat_set<Key, Hash, KeyEqual, Allocator> const& rhs);
+      concurrent_flat_set<Key, Hash, KeyEqual, Allocator, Spin> const& lhs,
+      concurrent_flat_set<Key, Hash, KeyEqual, Allocator, Spin> const& rhs);
 
-    template <class Key, class Hash, class Pred, class Alloc>
-    void swap(concurrent_flat_set<Key, Hash, Pred, Alloc>& x,
+    template <class Key, class Hash, class Pred, class Alloc, class Spin>
+    void swap(concurrent_flat_set<Key, Hash, Pred, Alloc, Spin>& x,
       concurrent_flat_set<Key, Hash, Pred, Alloc>& y)
       noexcept(noexcept(x.swap(y)));
 
-    template <class K, class H, class P, class A, class Predicate>
-    typename concurrent_flat_set<K, H, P, A>::size_type erase_if(
-      concurrent_flat_set<K, H, P, A>& c, Predicate pred);
+    template <class K, class H, class P, class A, class S, class Predicate>
+    typename concurrent_flat_set<K, H, P, A, S>::size_type erase_if(
+      concurrent_flat_set<K, H, P, A, S>& c, Predicate pred);
 
 #ifndef BOOST_NO_CXX17_HDR_MEMORY_RESOURCE
     namespace pmr {
-      template <class Key, class Hash = boost::hash<Key>,
+      template <class Key, class Spin, class Hash = boost::hash<Key>,
         class Pred = std::equal_to<Key> >
       using concurrent_flat_set = boost::unordered::concurrent_flat_set<Key,
-        Hash, Pred, std::pmr::polymorphic_allocator<Key> >;
+        Hash, Pred, std::pmr::polymorphic_allocator<Key>, Spin>;
     } // namespace pmr
 #endif
 
   } // namespace unordered
 
   using boost::unordered::concurrent_flat_set;
 } // namespace boost
 
 #endif // BOOST_UNORDERED_CONCURRENT_FLAT_SET_FWD_HPP
diff --git a/include/boost/unordered/concurrent_node_map.hpp b/include/boost/unordered/concurrent_node_map.hpp
index 1b6f1623..6922e567 100644
--- a/include/boost/unordered/concurrent_node_map.hpp
+++ b/include/boost/unordered/concurrent_node_map.hpp
@@ -12,70 +12,70 @@
 #ifndef BOOST_UNORDERED_CONCURRENT_NODE_MAP_HPP
 #define BOOST_UNORDERED_CONCURRENT_NODE_MAP_HPP
 
 #include <boost/unordered/concurrent_node_map_fwd.hpp>
 #include <boost/unordered/detail/concurrent_static_asserts.hpp>
 #include <boost/unordered/detail/foa/concurrent_table.hpp>
 #include <boost/unordered/detail/foa/element_type.hpp>
 #include <boost/unordered/detail/foa/node_map_handle.hpp>
 #include <boost/unordered/detail/foa/node_map_types.hpp>
 #include <boost/unordered/detail/type_traits.hpp>
 #include <boost/unordered/unordered_node_map_fwd.hpp>
 
 #include <boost/container_hash/hash.hpp>
 #include <boost/core/allocator_access.hpp>
 #include <boost/core/serialization.hpp>
 
 #include <type_traits>
 
 namespace boost {
   namespace unordered {
-    template <class Key, class T, class Hash, class Pred, class Allocator>
+    template <class Key, class T, class Hash, class Pred, class Allocator, class Spin>
     class concurrent_node_map
     {
     private:
       template <class Key2, class T2, class Hash2, class Pred2,
-        class Allocator2>
+        class Allocator2, class Spin2>
       friend class concurrent_node_map;
       template <class Key2, class T2, class Hash2, class Pred2,
         class Allocator2>
       friend class unordered_node_map;
 
       using type_policy = detail::foa::node_map_types<Key, T,
         typename boost::allocator_void_pointer<Allocator>::type>;
 
       using table_type =
-        detail::foa::concurrent_table<type_policy, Hash, Pred, Allocator>;
+        detail::foa::concurrent_table<type_policy, Hash, Pred, Allocator, Spin>;
 
       table_type table_;
 
-      template <class K, class V, class H, class KE, class A>
-      bool friend operator==(concurrent_node_map<K, V, H, KE, A> const& lhs,
-        concurrent_node_map<K, V, H, KE, A> const& rhs);
+      template <class K, class V, class H, class KE, class A, class S>
+      bool friend operator==(concurrent_node_map<K, V, H, KE, A, S> const& lhs,
+        concurrent_node_map<K, V, H, KE, A, S> const& rhs);
 
-      template <class K, class V, class H, class KE, class A, class Predicate>
-      friend typename concurrent_node_map<K, V, H, KE, A>::size_type erase_if(
-        concurrent_node_map<K, V, H, KE, A>& set, Predicate pred);
+      template <class K, class V, class H, class KE, class A, class S, class Predicate>
+      friend typename concurrent_node_map<K, V, H, KE, A, S>::size_type erase_if(
+        concurrent_node_map<K, V, H, KE, A, S>& set, Predicate pred);
 
-      template<class Archive, class K, class V, class H, class KE, class A>
+      template<class Archive, class K, class V, class H, class KE, class A, class S>
       friend void serialize(
-        Archive& ar, concurrent_node_map<K, V, H, KE, A>& c,
+        Archive& ar, concurrent_node_map<K, V, H, KE, A, S>& c,
         unsigned int version);
 
     public:
       using key_type = Key;
       using mapped_type = T;
       using value_type = typename type_policy::value_type;
       using init_type = typename type_policy::init_type;
       using size_type = std::size_t;
       using difference_type = std::ptrdiff_t;
       using hasher = typename boost::unordered::detail::type_identity<Hash>::type;
       using key_equal = typename boost::unordered::detail::type_identity<Pred>::type;
       using allocator_type = typename boost::unordered::detail::type_identity<Allocator>::type;
       using reference = value_type&;
       using const_reference = value_type const&;
       using pointer = typename boost::allocator_pointer<allocator_type>::type;
       using const_pointer =
         typename boost::allocator_const_pointer<allocator_type>::type;
       using node_type = detail::foa::node_map_handle<type_policy,
         typename boost::allocator_rebind<Allocator,
           typename type_policy::value_type>::type>;
@@ -1050,153 +1050,163 @@ namespace boost {
 
 #if defined(BOOST_UNORDERED_ENABLE_STATS)
       /// Stats
       ///
       stats get_stats() const { return table_.get_stats(); }
 
       void reset_stats() noexcept { table_.reset_stats(); }
 #endif
 
       /// Observers
       ///
       allocator_type get_allocator() const noexcept
       {
         return table_.get_allocator();
       }
 
       hasher hash_function() const { return table_.hash_function(); }
       key_equal key_eq() const { return table_.key_eq(); }
     };
 
-    template <class Key, class T, class Hash, class KeyEqual, class Allocator>
+    template <class Key, class T, class Hash, class KeyEqual, class Allocator, class Spin>
     bool operator==(
-      concurrent_node_map<Key, T, Hash, KeyEqual, Allocator> const& lhs,
-      concurrent_node_map<Key, T, Hash, KeyEqual, Allocator> const& rhs)
+      concurrent_node_map<Key, T, Hash, KeyEqual, Allocator, Spin> const& lhs,
+      concurrent_node_map<Key, T, Hash, KeyEqual, Allocator, Spin> const& rhs)
     {
       return lhs.table_ == rhs.table_;
     }
 
-    template <class Key, class T, class Hash, class KeyEqual, class Allocator>
+    template <class Key, class T, class Hash, class KeyEqual, class Allocator, class Spin>
     bool operator!=(
-      concurrent_node_map<Key, T, Hash, KeyEqual, Allocator> const& lhs,
-      concurrent_node_map<Key, T, Hash, KeyEqual, Allocator> const& rhs)
+      concurrent_node_map<Key, T, Hash, KeyEqual, Allocator, Spin> const& lhs,
+      concurrent_node_map<Key, T, Hash, KeyEqual, Allocator, Spin> const& rhs)
     {
       return !(lhs == rhs);
     }
 
-    template <class Key, class T, class Hash, class Pred, class Alloc>
-    void swap(concurrent_node_map<Key, T, Hash, Pred, Alloc>& x,
+    template <class Key, class T, class Hash, class Pred, class Alloc, class Spin>
+    void swap(concurrent_node_map<Key, T, Hash, Pred, Alloc, Spin>& x,
       concurrent_node_map<Key, T, Hash, Pred, Alloc>& y)
       noexcept(noexcept(x.swap(y)))
     {
       x.swap(y);
     }
 
-    template <class K, class T, class H, class P, class A, class Predicate>
-    typename concurrent_node_map<K, T, H, P, A>::size_type erase_if(
-      concurrent_node_map<K, T, H, P, A>& c, Predicate pred)
+    template <class K, class T, class H, class P, class A, class S, class Predicate>
+    typename concurrent_node_map<K, T, H, P, A, S>::size_type erase_if(
+      concurrent_node_map<K, T, H, P, A, S>& c, Predicate pred)
     {
       return c.table_.erase_if(pred);
     }
 
-    template<class Archive, class K, class V, class H, class KE, class A>
+    template<class Archive, class K, class V, class H, class KE, class A, class S>
     void serialize(
-      Archive& ar, concurrent_node_map<K, V, H, KE, A>& c, unsigned int)
+      Archive& ar, concurrent_node_map<K, V, H, KE, A, S>& c, unsigned int)
     {
       ar & core::make_nvp("table",c.table_);
     }
 
 #if BOOST_UNORDERED_TEMPLATE_DEDUCTION_GUIDES
 
     template <class InputIterator,
       class Hash =
         boost::hash<boost::unordered::detail::iter_key_t<InputIterator> >,
       class Pred =
         std::equal_to<boost::unordered::detail::iter_key_t<InputIterator> >,
       class Allocator = std::allocator<
         boost::unordered::detail::iter_to_alloc_t<InputIterator> >,
+      class Spin,
       class = std::enable_if_t<detail::is_input_iterator_v<InputIterator> >,
       class = std::enable_if_t<detail::is_hash_v<Hash> >,
       class = std::enable_if_t<detail::is_pred_v<Pred> >,
-      class = std::enable_if_t<detail::is_allocator_v<Allocator> > >
+      class = std::enable_if_t<detail::is_allocator_v<Allocator> >,
+      class = std::enable_if_t<detail::is_true_or_false_type_v<Spin> > >
     concurrent_node_map(InputIterator, InputIterator,
       std::size_t = boost::unordered::detail::foa::default_bucket_count,
-      Hash = Hash(), Pred = Pred(), Allocator = Allocator())
+      Hash = Hash(), Pred = Pred(), Allocator = Allocator(), Spin = Spin())
       -> concurrent_node_map<
         boost::unordered::detail::iter_key_t<InputIterator>,
         boost::unordered::detail::iter_val_t<InputIterator>, Hash, Pred,
-        Allocator>;
+        Allocator, Spin>;
 
     template <class Key, class T,
       class Hash = boost::hash<std::remove_const_t<Key> >,
       class Pred = std::equal_to<std::remove_const_t<Key> >,
       class Allocator = std::allocator<std::pair<const Key, T> >,
+      class Spin,
       class = std::enable_if_t<detail::is_hash_v<Hash> >,
       class = std::enable_if_t<detail::is_pred_v<Pred> >,
-      class = std::enable_if_t<detail::is_allocator_v<Allocator> > >
+      class = std::enable_if_t<detail::is_allocator_v<Allocator> >,
+      class = std::enable_if_t<detail::is_true_or_false_type_v<Spin> > >
     concurrent_node_map(std::initializer_list<std::pair<Key, T> >,
       std::size_t = boost::unordered::detail::foa::default_bucket_count,
-      Hash = Hash(), Pred = Pred(), Allocator = Allocator())
+      Hash = Hash(), Pred = Pred(), Allocator = Allocator(), Spin = Spin())
       -> concurrent_node_map<std::remove_const_t<Key>, T, Hash, Pred,
-        Allocator>;
+        Allocator, Spin>;
 
-    template <class InputIterator, class Allocator,
+    template <class InputIterator, class Allocator, class Spin,
       class = std::enable_if_t<detail::is_input_iterator_v<InputIterator> >,
-      class = std::enable_if_t<detail::is_allocator_v<Allocator> > >
-    concurrent_node_map(InputIterator, InputIterator, std::size_t, Allocator)
+      class = std::enable_if_t<detail::is_allocator_v<Allocator> >,
+      class = std::enable_if_t<detail::is_true_or_false_type_v<Spin> > >
+    concurrent_node_map(InputIterator, InputIterator, std::size_t, Allocator, Spin)
       -> concurrent_node_map<
         boost::unordered::detail::iter_key_t<InputIterator>,
         boost::unordered::detail::iter_val_t<InputIterator>,
         boost::hash<boost::unordered::detail::iter_key_t<InputIterator> >,
         std::equal_to<boost::unordered::detail::iter_key_t<InputIterator> >,
-        Allocator>;
+        Allocator, Spin>;
 
-    template <class InputIterator, class Allocator,
+    template <class InputIterator, class Allocator, class Spin,
       class = std::enable_if_t<detail::is_input_iterator_v<InputIterator> >,
-      class = std::enable_if_t<detail::is_allocator_v<Allocator> > >
-    concurrent_node_map(InputIterator, InputIterator, Allocator)
+      class = std::enable_if_t<detail::is_allocator_v<Allocator> >,
+      class = std::enable_if_t<detail::is_true_or_false_type_v<Spin> > >
+    concurrent_node_map(InputIterator, InputIterator, Allocator, Spin)
       -> concurrent_node_map<
         boost::unordered::detail::iter_key_t<InputIterator>,
         boost::unordered::detail::iter_val_t<InputIterator>,
         boost::hash<boost::unordered::detail::iter_key_t<InputIterator> >,
         std::equal_to<boost::unordered::detail::iter_key_t<InputIterator> >,
-        Allocator>;
+        Allocator, Spin>;
 
-    template <class InputIterator, class Hash, class Allocator,
+    template <class InputIterator, class Hash, class Allocator, class Spin,
       class = std::enable_if_t<detail::is_hash_v<Hash> >,
       class = std::enable_if_t<detail::is_input_iterator_v<InputIterator> >,
-      class = std::enable_if_t<detail::is_allocator_v<Allocator> > >
+      class = std::enable_if_t<detail::is_allocator_v<Allocator> >,
+      class = std::enable_if_t<detail::is_true_or_false_type_v<Spin> > >
     concurrent_node_map(
-      InputIterator, InputIterator, std::size_t, Hash, Allocator)
+      InputIterator, InputIterator, std::size_t, Hash, Allocator, Spin)
       -> concurrent_node_map<
         boost::unordered::detail::iter_key_t<InputIterator>,
         boost::unordered::detail::iter_val_t<InputIterator>, Hash,
         std::equal_to<boost::unordered::detail::iter_key_t<InputIterator> >,
-        Allocator>;
+        Allocator, Spin>;
 
-    template <class Key, class T, class Allocator,
-      class = std::enable_if_t<detail::is_allocator_v<Allocator> > >
+    template <class Key, class T, class Allocator, class Spin,
+      class = std::enable_if_t<detail::is_allocator_v<Allocator> >,
+      class = std::enable_if_t<detail::is_true_or_false_type_v<Spin> > >
     concurrent_node_map(std::initializer_list<std::pair<Key, T> >, std::size_t,
-      Allocator) -> concurrent_node_map<std::remove_const_t<Key>, T,
+      Allocator, Spin) -> concurrent_node_map<std::remove_const_t<Key>, T,
       boost::hash<std::remove_const_t<Key> >,
-      std::equal_to<std::remove_const_t<Key> >, Allocator>;
+      std::equal_to<std::remove_const_t<Key> >, Allocator, Spin>;
 
-    template <class Key, class T, class Allocator,
-      class = std::enable_if_t<detail::is_allocator_v<Allocator> > >
-    concurrent_node_map(std::initializer_list<std::pair<Key, T> >, Allocator)
+    template <class Key, class T, class Allocator, class Spin,
+      class = std::enable_if_t<detail::is_allocator_v<Allocator> >,
+      class = std::enable_if_t<detail::is_true_or_false_type_v<Spin> > >
+    concurrent_node_map(std::initializer_list<std::pair<Key, T> >, Allocator, Spin)
       -> concurrent_node_map<std::remove_const_t<Key>, T,
         boost::hash<std::remove_const_t<Key> >,
-        std::equal_to<std::remove_const_t<Key> >, Allocator>;
+        std::equal_to<std::remove_const_t<Key> >, Allocator, Spin>;
 
-    template <class Key, class T, class Hash, class Allocator,
+    template <class Key, class T, class Hash, class Allocator, class Spin,
       class = std::enable_if_t<detail::is_hash_v<Hash> >,
-      class = std::enable_if_t<detail::is_allocator_v<Allocator> > >
+      class = std::enable_if_t<detail::is_allocator_v<Allocator> >,
+      class = std::enable_if_t<detail::is_true_or_false_type_v<Spin> > >
     concurrent_node_map(std::initializer_list<std::pair<Key, T> >, std::size_t,
-      Hash, Allocator) -> concurrent_node_map<std::remove_const_t<Key>, T,
+      Hash, Allocator, Spin) -> concurrent_node_map<std::remove_const_t<Key>, T,
       Hash, std::equal_to<std::remove_const_t<Key> >, Allocator>;
 
 #endif
 
   } // namespace unordered
 } // namespace boost
 
 #endif // BOOST_UNORDERED_CONCURRENT_NODE_MAP_HPP
diff --git a/include/boost/unordered/concurrent_node_map_fwd.hpp b/include/boost/unordered/concurrent_node_map_fwd.hpp
index dd1f6fc0..c36f1333 100644
--- a/include/boost/unordered/concurrent_node_map_fwd.hpp
+++ b/include/boost/unordered/concurrent_node_map_fwd.hpp
@@ -11,57 +11,58 @@
  */
 
 #ifndef BOOST_UNORDERED_CONCURRENT_NODE_MAP_FWD_HPP
 #define BOOST_UNORDERED_CONCURRENT_NODE_MAP_FWD_HPP
 
 #include <boost/config.hpp>
 #include <boost/container_hash/hash_fwd.hpp>
 
 #include <functional>
 #include <memory>
 
 #ifndef BOOST_NO_CXX17_HDR_MEMORY_RESOURCE
 #include <memory_resource>
 #endif
 
 namespace boost {
   namespace unordered {
 
     template <class Key, class T, class Hash = boost::hash<Key>,
       class Pred = std::equal_to<Key>,
-      class Allocator = std::allocator<std::pair<Key const, T> > >
+      class Allocator = std::allocator<std::pair<Key const, T> >,
+      class Spin = std::true_type>
     class concurrent_node_map;
 
-    template <class Key, class T, class Hash, class KeyEqual, class Allocator>
+    template <class Key, class T, class Hash, class KeyEqual, class Allocator, class Spin>
     bool operator==(
-      concurrent_node_map<Key, T, Hash, KeyEqual, Allocator> const& lhs,
-      concurrent_node_map<Key, T, Hash, KeyEqual, Allocator> const& rhs);
+      concurrent_node_map<Key, T, Hash, KeyEqual, Allocator, Spin> const& lhs,
+      concurrent_node_map<Key, T, Hash, KeyEqual, Allocator, Spin> const& rhs);
 
-    template <class Key, class T, class Hash, class KeyEqual, class Allocator>
+    template <class Key, class T, class Hash, class KeyEqual, class Allocator, class Spin>
     bool operator!=(
-      concurrent_node_map<Key, T, Hash, KeyEqual, Allocator> const& lhs,
-      concurrent_node_map<Key, T, Hash, KeyEqual, Allocator> const& rhs);
+      concurrent_node_map<Key, T, Hash, KeyEqual, Allocator, Spin> const& lhs,
+      concurrent_node_map<Key, T, Hash, KeyEqual, Allocator, Spin> const& rhs);
 
-    template <class Key, class T, class Hash, class Pred, class Alloc>
-    void swap(concurrent_node_map<Key, T, Hash, Pred, Alloc>& x,
-      concurrent_node_map<Key, T, Hash, Pred, Alloc>& y)
+    template <class Key, class T, class Hash, class Pred, class Alloc, class Spin>
+    void swap(concurrent_node_map<Key, T, Hash, Pred, Alloc, Spin>& x,
+      concurrent_node_map<Key, T, Hash, Pred, Alloc, Spin>& y)
       noexcept(noexcept(x.swap(y)));
 
-    template <class K, class T, class H, class P, class A, class Predicate>
-    typename concurrent_node_map<K, T, H, P, A>::size_type erase_if(
-      concurrent_node_map<K, T, H, P, A>& c, Predicate pred);
+    template <class K, class T, class H, class P, class A, class S, class Predicate>
+    typename concurrent_node_map<K, T, H, P, A, S>::size_type erase_if(
+      concurrent_node_map<K, T, H, P, A, S>& c, Predicate pred);
 
 #ifndef BOOST_NO_CXX17_HDR_MEMORY_RESOURCE
     namespace pmr {
       template <class Key, class T, class Hash = boost::hash<Key>,
-        class Pred = std::equal_to<Key> >
+        class Pred = std::equal_to<Key>, class Spin = std::true_type >
       using concurrent_node_map = boost::unordered::concurrent_node_map<Key, T,
         Hash, Pred, std::pmr::polymorphic_allocator<std::pair<Key const, T> > >;
     } // namespace pmr
 #endif
 
   } // namespace unordered
 
   using boost::unordered::concurrent_node_map;
 } // namespace boost
 
 #endif // BOOST_UNORDERED_CONCURRENT_NODE_MAP_FWD_HPP
diff --git a/include/boost/unordered/concurrent_node_set.hpp b/include/boost/unordered/concurrent_node_set.hpp
index 430bc079..386263dc 100644
--- a/include/boost/unordered/concurrent_node_set.hpp
+++ b/include/boost/unordered/concurrent_node_set.hpp
@@ -12,68 +12,68 @@
 #ifndef BOOST_UNORDERED_CONCURRENT_NODE_SET_HPP
 #define BOOST_UNORDERED_CONCURRENT_NODE_SET_HPP
 
 #include <boost/unordered/concurrent_node_set_fwd.hpp>
 #include <boost/unordered/detail/concurrent_static_asserts.hpp>
 #include <boost/unordered/detail/foa/concurrent_table.hpp>
 #include <boost/unordered/detail/foa/element_type.hpp>
 #include <boost/unordered/detail/foa/node_set_handle.hpp>
 #include <boost/unordered/detail/foa/node_set_types.hpp>
 #include <boost/unordered/detail/type_traits.hpp>
 #include <boost/unordered/unordered_node_set_fwd.hpp>
 
 #include <boost/container_hash/hash.hpp>
 #include <boost/core/allocator_access.hpp>
 #include <boost/core/serialization.hpp>
 
 #include <utility>
 
 namespace boost {
   namespace unordered {
-    template <class Key, class Hash, class Pred, class Allocator>
+    template <class Key, class Hash, class Pred, class Allocator, class Spin>
     class concurrent_node_set
     {
     private:
-      template <class Key2, class Hash2, class Pred2, class Allocator2>
+      template <class Key2, class Hash2, class Pred2, class Allocator2, class Spin2>
       friend class concurrent_node_set;
       template <class Key2, class Hash2, class Pred2, class Allocator2>
       friend class unordered_node_set;
 
       using type_policy = detail::foa::node_set_types<Key,
         typename boost::allocator_void_pointer<Allocator>::type>;
 
       using table_type =
-        detail::foa::concurrent_table<type_policy, Hash, Pred, Allocator>;
+        detail::foa::concurrent_table<type_policy, Hash, Pred, Allocator, Spin>;
 
       table_type table_;
 
-      template <class K, class H, class KE, class A>
-      bool friend operator==(concurrent_node_set<K, H, KE, A> const& lhs,
-        concurrent_node_set<K, H, KE, A> const& rhs);
+      template <class K, class H, class KE, class A, class S>
+      bool friend operator==(concurrent_node_set<K, H, KE, A, S> const& lhs,
+        concurrent_node_set<K, H, KE, A, S> const& rhs);
 
-      template <class K, class H, class KE, class A, class Predicate>
-      friend typename concurrent_node_set<K, H, KE, A>::size_type erase_if(
-        concurrent_node_set<K, H, KE, A>& set, Predicate pred);
+      template <class K, class H, class KE, class A, class S, class Predicate>
+      friend typename concurrent_node_set<K, H, KE, A, S>::size_type erase_if(
+        concurrent_node_set<K, H, KE, A, S>& set, Predicate pred);
 
-      template<class Archive, class K, class H, class KE, class A>
+      template<class Archive, class K, class H, class KE, class A, class S>
       friend void serialize(
-        Archive& ar, concurrent_node_set<K, H, KE, A>& c,
+        Archive& ar, concurrent_node_set<K, H, KE, A, S>& c,
         unsigned int version);
 
     public:
       using key_type = Key;
       using value_type = typename type_policy::value_type;
       using init_type = typename type_policy::init_type;
       using size_type = std::size_t;
       using difference_type = std::ptrdiff_t;
       using hasher = typename boost::unordered::detail::type_identity<Hash>::type;
       using key_equal = typename boost::unordered::detail::type_identity<Pred>::type;
       using allocator_type = typename boost::unordered::detail::type_identity<Allocator>::type;
       using reference = value_type&;
       using const_reference = value_type const&;
       using pointer = typename boost::allocator_pointer<allocator_type>::type;
       using const_pointer =
         typename boost::allocator_const_pointer<allocator_type>::type;
       using node_type = detail::foa::node_set_handle<type_policy,
         typename boost::allocator_rebind<Allocator,
           typename type_policy::value_type>::type>;
       using insert_return_type =
@@ -925,141 +925,151 @@ namespace boost {
 
 #if defined(BOOST_UNORDERED_ENABLE_STATS)
       /// Stats
       ///
       stats get_stats() const { return table_.get_stats(); }
 
       void reset_stats() noexcept { table_.reset_stats(); }
 #endif
 
       /// Observers
       ///
       allocator_type get_allocator() const noexcept
       {
         return table_.get_allocator();
       }
 
       hasher hash_function() const { return table_.hash_function(); }
       key_equal key_eq() const { return table_.key_eq(); }
     };
 
-    template <class Key, class Hash, class KeyEqual, class Allocator>
+    template <class Key, class Hash, class KeyEqual, class Allocator, class Spin>
     bool operator==(
-      concurrent_node_set<Key, Hash, KeyEqual, Allocator> const& lhs,
-      concurrent_node_set<Key, Hash, KeyEqual, Allocator> const& rhs)
+      concurrent_node_set<Key, Hash, KeyEqual, Allocator, Spin> const& lhs,
+      concurrent_node_set<Key, Hash, KeyEqual, Allocator, Spin> const& rhs)
     {
       return lhs.table_ == rhs.table_;
     }
 
-    template <class Key, class Hash, class KeyEqual, class Allocator>
+    template <class Key, class Hash, class KeyEqual, class Allocator, class Spin>
     bool operator!=(
-      concurrent_node_set<Key, Hash, KeyEqual, Allocator> const& lhs,
-      concurrent_node_set<Key, Hash, KeyEqual, Allocator> const& rhs)
+      concurrent_node_set<Key, Hash, KeyEqual, Allocator, Spin> const& lhs,
+      concurrent_node_set<Key, Hash, KeyEqual, Allocator, Spin> const& rhs)
     {
       return !(lhs == rhs);
     }
 
-    template <class Key, class Hash, class Pred, class Alloc>
-    void swap(concurrent_node_set<Key, Hash, Pred, Alloc>& x,
-      concurrent_node_set<Key, Hash, Pred, Alloc>& y)
+    template <class Key, class Hash, class Pred, class Alloc, class Spin>
+    void swap(concurrent_node_set<Key, Hash, Pred, Alloc, Spin>& x,
+      concurrent_node_set<Key, Hash, Pred, Alloc, Spin>& y)
       noexcept(noexcept(x.swap(y)))
     {
       x.swap(y);
     }
 
-    template <class K, class H, class P, class A, class Predicate>
-    typename concurrent_node_set<K, H, P, A>::size_type erase_if(
-      concurrent_node_set<K, H, P, A>& c, Predicate pred)
+    template <class K, class H, class P, class A, class S, class Predicate>
+    typename concurrent_node_set<K, H, P, A, S>::size_type erase_if(
+      concurrent_node_set<K, H, P, A, S>& c, Predicate pred)
     {
       return c.table_.erase_if(pred);
     }
 
-    template<class Archive, class K, class H, class KE, class A>
+    template<class Archive, class K, class H, class KE, class A, class S>
     void serialize(
-      Archive& ar, concurrent_node_set<K, H, KE, A>& c, unsigned int)
+      Archive& ar, concurrent_node_set<K, H, KE, A, S>& c, unsigned int)
     {
       ar & core::make_nvp("table",c.table_);
     }
 
 #if BOOST_UNORDERED_TEMPLATE_DEDUCTION_GUIDES
 
     template <class InputIterator,
       class Hash =
         boost::hash<typename std::iterator_traits<InputIterator>::value_type>,
       class Pred =
         std::equal_to<typename std::iterator_traits<InputIterator>::value_type>,
       class Allocator = std::allocator<
         typename std::iterator_traits<InputIterator>::value_type>,
+      class Spin,
       class = std::enable_if_t<detail::is_input_iterator_v<InputIterator> >,
       class = std::enable_if_t<detail::is_hash_v<Hash> >,
       class = std::enable_if_t<detail::is_pred_v<Pred> >,
-      class = std::enable_if_t<detail::is_allocator_v<Allocator> > >
+      class = std::enable_if_t<detail::is_allocator_v<Allocator> >,
+      class = std::enable_if_t<detail::is_true_or_false_type_v<Spin> > >
     concurrent_node_set(InputIterator, InputIterator,
       std::size_t = boost::unordered::detail::foa::default_bucket_count,
-      Hash = Hash(), Pred = Pred(), Allocator = Allocator())
+      Hash = Hash(), Pred = Pred(), Allocator = Allocator(), Spin = Spin())
       -> concurrent_node_set<
         typename std::iterator_traits<InputIterator>::value_type, Hash, Pred,
-        Allocator>;
+        Allocator, Spin>;
 
     template <class T, class Hash = boost::hash<T>,
       class Pred = std::equal_to<T>, class Allocator = std::allocator<T>,
+      class Spin,
       class = std::enable_if_t<detail::is_hash_v<Hash> >,
       class = std::enable_if_t<detail::is_pred_v<Pred> >,
-      class = std::enable_if_t<detail::is_allocator_v<Allocator> > >
+      class = std::enable_if_t<detail::is_allocator_v<Allocator> >,
+      class = std::enable_if_t<detail::is_true_or_false_type_v<Spin> > >
     concurrent_node_set(std::initializer_list<T>,
       std::size_t = boost::unordered::detail::foa::default_bucket_count,
-      Hash = Hash(), Pred = Pred(), Allocator = Allocator())
-      -> concurrent_node_set< T, Hash, Pred, Allocator>;
+      Hash = Hash(), Pred = Pred(), Allocator = Allocator(), Spin = Spin())
+      -> concurrent_node_set< T, Hash, Pred, Allocator, Spin>;
 
-    template <class InputIterator, class Allocator,
+    template <class InputIterator, class Allocator, class Spin,
       class = std::enable_if_t<detail::is_input_iterator_v<InputIterator> >,
-      class = std::enable_if_t<detail::is_allocator_v<Allocator> > >
-    concurrent_node_set(InputIterator, InputIterator, std::size_t, Allocator)
+      class = std::enable_if_t<detail::is_allocator_v<Allocator> >,
+      class = std::enable_if_t<detail::is_true_or_false_type_v<Spin> > >
+    concurrent_node_set(InputIterator, InputIterator, std::size_t, Allocator, Spin)
       -> concurrent_node_set<
         typename std::iterator_traits<InputIterator>::value_type,
         boost::hash<typename std::iterator_traits<InputIterator>::value_type>,
         std::equal_to<typename std::iterator_traits<InputIterator>::value_type>,
-        Allocator>;
+        Allocator, Spin>;
 
-    template <class InputIterator, class Allocator,
+    template <class InputIterator, class Allocator, class Spin,
       class = std::enable_if_t<detail::is_input_iterator_v<InputIterator> >,
-      class = std::enable_if_t<detail::is_allocator_v<Allocator> > >
-    concurrent_node_set(InputIterator, InputIterator, Allocator)
+      class = std::enable_if_t<detail::is_allocator_v<Allocator> >,
+      class = std::enable_if_t<detail::is_true_or_false_type_v<Spin> > >
+    concurrent_node_set(InputIterator, InputIterator, Allocator, Spin)
       -> concurrent_node_set<
         typename std::iterator_traits<InputIterator>::value_type,
         boost::hash<typename std::iterator_traits<InputIterator>::value_type>,
         std::equal_to<typename std::iterator_traits<InputIterator>::value_type>,
-        Allocator>;
+        Allocator, Spin>;
 
-    template <class InputIterator, class Hash, class Allocator,
+    template <class InputIterator, class Hash, class Allocator, class Spin,
       class = std::enable_if_t<detail::is_hash_v<Hash> >,
       class = std::enable_if_t<detail::is_input_iterator_v<InputIterator> >,
-      class = std::enable_if_t<detail::is_allocator_v<Allocator> > >
+      class = std::enable_if_t<detail::is_allocator_v<Allocator> >,
+      class = std::enable_if_t<detail::is_true_or_false_type_v<Spin> > >
     concurrent_node_set(
-      InputIterator, InputIterator, std::size_t, Hash, Allocator)
+      InputIterator, InputIterator, std::size_t, Hash, Allocator, Spin)
       -> concurrent_node_set<
         typename std::iterator_traits<InputIterator>::value_type, Hash,
         std::equal_to<typename std::iterator_traits<InputIterator>::value_type>,
-        Allocator>;
+        Allocator, Spin>;
 
-    template <class T, class Allocator,
-      class = std::enable_if_t<detail::is_allocator_v<Allocator> > >
-    concurrent_node_set(std::initializer_list<T>, std::size_t, Allocator)
-      -> concurrent_node_set<T, boost::hash<T>,std::equal_to<T>, Allocator>;
+    template <class T, class Allocator, class Spin,
+      class = std::enable_if_t<detail::is_allocator_v<Allocator> >,
+      class = std::enable_if_t<detail::is_true_or_false_type_v<Spin> > >
+    concurrent_node_set(std::initializer_list<T>, std::size_t, Allocator, Spin)
+      -> concurrent_node_set<T, boost::hash<T>,std::equal_to<T>, Allocator, Spin>;
 
-    template <class T, class Allocator,
-      class = std::enable_if_t<detail::is_allocator_v<Allocator> > >
-    concurrent_node_set(std::initializer_list<T >, Allocator)
-      -> concurrent_node_set<T, boost::hash<T>, std::equal_to<T>, Allocator>;
+    template <class T, class Allocator, class Spin,
+      class = std::enable_if_t<detail::is_allocator_v<Allocator> >,
+      class = std::enable_if_t<detail::is_true_or_false_type_v<Spin> > >
+    concurrent_node_set(std::initializer_list<T >, Allocator, Spin)
+      -> concurrent_node_set<T, boost::hash<T>, std::equal_to<T>, Allocator, Spin>;
 
-    template <class T, class Hash, class Allocator,
+    template <class T, class Hash, class Allocator, class Spin,
       class = std::enable_if_t<detail::is_hash_v<Hash> >,
-      class = std::enable_if_t<detail::is_allocator_v<Allocator> > >
-    concurrent_node_set(std::initializer_list<T >, std::size_t,Hash, Allocator)
-      -> concurrent_node_set<T, Hash, std::equal_to<T>, Allocator>;
+      class = std::enable_if_t<detail::is_allocator_v<Allocator> >,
+      class = std::enable_if_t<detail::is_true_or_false_type_v<Spin> > >
+    concurrent_node_set(std::initializer_list<T >, std::size_t,Hash, Allocator, Spin)
+      -> concurrent_node_set<T, Hash, std::equal_to<T>, Allocator, Spin>;
 
 #endif
 
   } // namespace unordered
 } // namespace boost
 
 #endif // BOOST_UNORDERED_CONCURRENT_NODE_SET_HPP
diff --git a/include/boost/unordered/concurrent_node_set_fwd.hpp b/include/boost/unordered/concurrent_node_set_fwd.hpp
index 62e06614..2e486747 100644
--- a/include/boost/unordered/concurrent_node_set_fwd.hpp
+++ b/include/boost/unordered/concurrent_node_set_fwd.hpp
@@ -11,57 +11,58 @@
  */
 
 #ifndef BOOST_UNORDERED_CONCURRENT_NODE_SET_FWD_HPP
 #define BOOST_UNORDERED_CONCURRENT_NODE_SET_FWD_HPP
 
 #include <boost/config.hpp>
 #include <boost/container_hash/hash_fwd.hpp>
 
 #include <functional>
 #include <memory>
 
 #ifndef BOOST_NO_CXX17_HDR_MEMORY_RESOURCE
 #include <memory_resource>
 #endif
 
 namespace boost {
   namespace unordered {
 
     template <class Key, class Hash = boost::hash<Key>,
       class Pred = std::equal_to<Key>,
-      class Allocator = std::allocator<Key> >
+      class Allocator = std::allocator<Key>,
+      class Spin = std::true_type>
     class concurrent_node_set;
 
-    template <class Key, class Hash, class KeyEqual, class Allocator>
+    template <class Key, class Hash, class KeyEqual, class Allocator, class Spin>
     bool operator==(
-      concurrent_node_set<Key, Hash, KeyEqual, Allocator> const& lhs,
-      concurrent_node_set<Key, Hash, KeyEqual, Allocator> const& rhs);
+      concurrent_node_set<Key, Hash, KeyEqual, Allocator, Spin> const& lhs,
+      concurrent_node_set<Key, Hash, KeyEqual, Allocator, Spin> const& rhs);
 
-    template <class Key, class Hash, class KeyEqual, class Allocator>
+    template <class Key, class Hash, class KeyEqual, class Allocator, class Spin>
     bool operator!=(
-      concurrent_node_set<Key, Hash, KeyEqual, Allocator> const& lhs,
-      concurrent_node_set<Key, Hash, KeyEqual, Allocator> const& rhs);
+      concurrent_node_set<Key, Hash, KeyEqual, Allocator, Spin> const& lhs,
+      concurrent_node_set<Key, Hash, KeyEqual, Allocator, Spin> const& rhs);
 
-    template <class Key, class Hash, class Pred, class Alloc>
-    void swap(concurrent_node_set<Key, Hash, Pred, Alloc>& x,
-      concurrent_node_set<Key, Hash, Pred, Alloc>& y)
+    template <class Key, class Hash, class Pred, class Alloc, class Spin>
+    void swap(concurrent_node_set<Key, Hash, Pred, Alloc, Spin>& x,
+      concurrent_node_set<Key, Hash, Pred, Alloc, Spin>& y)
       noexcept(noexcept(x.swap(y)));
 
-    template <class K, class H, class P, class A, class Predicate>
-    typename concurrent_node_set<K, H, P, A>::size_type erase_if(
-      concurrent_node_set<K, H, P, A>& c, Predicate pred);
+    template <class K, class H, class P, class A, class S, class Predicate>
+    typename concurrent_node_set<K, H, P, A, S>::size_type erase_if(
+      concurrent_node_set<K, H, P, A, S>& c, Predicate pred);
 
 #ifndef BOOST_NO_CXX17_HDR_MEMORY_RESOURCE
     namespace pmr {
-      template <class Key, class Hash = boost::hash<Key>,
+      template <class Key, class Spin, class Hash = boost::hash<Key>,
         class Pred = std::equal_to<Key> >
       using concurrent_node_set = boost::unordered::concurrent_node_set<Key,
-        Hash, Pred, std::pmr::polymorphic_allocator<Key> >;
+        Hash, Pred, std::pmr::polymorphic_allocator<Key>, Spin>;
     } // namespace pmr
 #endif
 
   } // namespace unordered
 
   using boost::unordered::concurrent_node_set;
 } // namespace boost
 
 #endif // BOOST_UNORDERED_CONCURRENT_NODE_SET_FWD_HPP
diff --git a/include/boost/unordered/detail/foa/concurrent_table.hpp b/include/boost/unordered/detail/foa/concurrent_table.hpp
index d2f0991c..718e993a 100644
--- a/include/boost/unordered/detail/foa/concurrent_table.hpp
+++ b/include/boost/unordered/detail/foa/concurrent_table.hpp
@@ -13,40 +13,41 @@
 #define BOOST_UNORDERED_DETAIL_FOA_CONCURRENT_TABLE_HPP
 
 #include <atomic>
 #include <boost/assert.hpp>
 #include <boost/config.hpp>
 #include <boost/core/ignore_unused.hpp>
 #include <boost/core/no_exceptions_support.hpp>
 #include <boost/core/serialization.hpp>
 #include <boost/cstdint.hpp>
 #include <boost/mp11/tuple.hpp>
 #include <boost/throw_exception.hpp>
 #include <boost/unordered/detail/archive_constructed.hpp>
 #include <boost/unordered/detail/bad_archive_exception.hpp>
 #include <boost/unordered/detail/foa/core.hpp>
 #include <boost/unordered/detail/foa/reentrancy_check.hpp>
 #include <boost/unordered/detail/foa/rw_spinlock.hpp>
 #include <boost/unordered/detail/foa/tuple_rotate_right.hpp>
 #include <boost/unordered/detail/serialization_version.hpp>
 #include <boost/unordered/detail/static_assert.hpp>
 #include <boost/unordered/detail/type_traits.hpp>
+#include <boost/thread/lock_algorithms.hpp>
 #include <cstddef>
 #include <functional>
 #include <initializer_list>
 #include <iterator>
 #include <memory>
 #include <new>
 #include <type_traits>
 #include <tuple>
 #include <utility>
 
 #if !defined(BOOST_UNORDERED_DISABLE_PARALLEL_ALGORITHMS)
 #if defined(BOOST_UNORDERED_ENABLE_PARALLEL_ALGORITHMS)|| \
     !defined(BOOST_NO_CXX17_HDR_EXECUTION)
 #define BOOST_UNORDERED_PARALLEL_ALGORITHMS
 #endif
 #endif
 
 #if defined(BOOST_UNORDERED_PARALLEL_ALGORITHMS)
 #include <algorithm>
 #include <execution>
@@ -201,131 +202,133 @@ template<typename Integral>
 struct atomic_integral
 {
   operator Integral()const{return n.load(std::memory_order_relaxed);}
   void operator=(Integral m){n.store(m,std::memory_order_relaxed);}
   void operator|=(Integral m){n.fetch_or(m,std::memory_order_relaxed);}
   void operator&=(Integral m){n.fetch_and(m,std::memory_order_relaxed);}
 
   atomic_integral& operator=(atomic_integral const& rhs) {
     n.store(rhs.n.load(std::memory_order_relaxed),std::memory_order_relaxed);
     return *this;
   }
 
   std::atomic<Integral> n;
 };
 
 /* Group-level concurrency protection. It provides a rw mutex plus an
  * atomic insertion counter for optimistic insertion (see
  * unprotected_norehash_emplace_and_visit).
  */
 
+template <typename Spin>
 struct group_access
-{    
-  using mutex_type=rw_spinlock;
+{
+  using mutex_type = std::conditional_t<Spin::value, rw_spinlock,
+    boost::interprocess::interprocess_sharable_mutex>;
   using shared_lock_guard=shared_lock<mutex_type>;
   using exclusive_lock_guard=lock_guard<mutex_type>;
   using insert_counter_type=std::atomic<boost::uint32_t>;
 
   shared_lock_guard    shared_access(){return shared_lock_guard{m};}
   exclusive_lock_guard exclusive_access(){return exclusive_lock_guard{m};}
   insert_counter_type& insert_counter(){return cnt;}
 
 private:
   mutex_type          m;
   insert_counter_type cnt{0};
 };
 
-template<std::size_t Size>
-group_access* dummy_group_accesses()
+template<std::size_t Size, typename Spin>
+group_access<Spin>* dummy_group_accesses()
 {
   /* Default group_access array to provide to empty containers without
    * incurring dynamic allocation. Mutexes won't actually ever be used,
    * (no successful reduced hash match) and insertion counters won't ever
    * be incremented (insertions won't succeed as capacity()==0).
    */
 
-  static group_access accesses[Size];
+  static group_access<Spin> accesses[Size];
 
   return accesses;
 }
 
 /* subclasses table_arrays to add an additional group_access array */
 
-template<typename Value,typename Group,typename SizePolicy,typename Allocator>
-struct concurrent_table_arrays:table_arrays<Value,Group,SizePolicy,Allocator>
+template<typename Value,typename Group,typename SizePolicy,typename Allocator,typename Spin>
+struct concurrent_table_arrays:table_arrays<Value,Group,SizePolicy,Allocator,Spin>
 {
   using group_access_allocator_type=
-    typename boost::allocator_rebind<Allocator,group_access>::type;
+    typename boost::allocator_rebind<Allocator,group_access<Spin>>::type;
   using group_access_pointer=
     typename boost::allocator_pointer<group_access_allocator_type>::type;
 
-  using super=table_arrays<Value,Group,SizePolicy,Allocator>;
+  using super=table_arrays<Value,Group,SizePolicy,Allocator,Spin>;
   using allocator_type=typename super::allocator_type;
 
   concurrent_table_arrays(const super& arrays,group_access_pointer pga):
     super{arrays},group_accesses_{pga}{}
 
-  group_access* group_accesses()const noexcept{
+  group_access<Spin>* group_accesses()const noexcept{
     return boost::to_address(group_accesses_);
   }
 
   static concurrent_table_arrays new_(allocator_type al,std::size_t n)
   {
     super x{super::new_(al,n)};
     BOOST_TRY{
       return new_group_access(group_access_allocator_type(al),x);
     }
     BOOST_CATCH(...){
       super::delete_(al,x);
       BOOST_RETHROW
     }
     BOOST_CATCH_END
   }
 
   static void set_group_access(
     group_access_allocator_type al,concurrent_table_arrays& arrays)
   {
     set_group_access(
-      al,arrays,std::is_same<group_access*,group_access_pointer>{});
+      al,arrays,std::is_same<group_access<Spin>*,group_access_pointer>{});
   }
 
   static void set_group_access(
     group_access_allocator_type al,
     concurrent_table_arrays& arrays,
     std::false_type /* fancy pointers */)
   {
     arrays.group_accesses_=
         boost::allocator_allocate(al,arrays.groups_size_mask+1);
 
       for(std::size_t i=0;i<arrays.groups_size_mask+1;++i){
-        ::new (arrays.group_accesses()+i) group_access();
+        ::new (arrays.group_accesses()+i) group_access<Spin>();
       }
   }
 
   static void set_group_access(
     group_access_allocator_type al,
     concurrent_table_arrays& arrays,
     std::true_type /* optimize when elements() is null */)
   {
     if(!arrays.elements()){
       arrays.group_accesses_=
-        dummy_group_accesses<SizePolicy::min_size()>();
+        dummy_group_accesses<SizePolicy::min_size(),Spin>();
     } else {
       set_group_access(al,arrays,std::false_type{});
     }
   }
 
   static concurrent_table_arrays new_group_access(
     group_access_allocator_type al,const super& x)
   {
     concurrent_table_arrays arrays{x,nullptr};
     set_group_access(al,arrays);
     return arrays;
   }
 
   static void delete_(allocator_type al,concurrent_table_arrays& arrays)noexcept
   {
     delete_group_access(group_access_allocator_type(al),arrays);
     super::delete_(al,arrays);
   }
 
   static void delete_group_access(
@@ -412,129 +415,133 @@ inline void swap(atomic_size_control& x,atomic_size_control& y)
  *   - Each group of slots has an associated rw spinlock. A thread holds
  *     at most one group lock at any given time. Lookup is implemented in
  *     a (groupwise) lock-free manner until a reduced hash match is found, in
  *     which case the relevant group is locked and the slot is double-checked
  *     for occupancy and compared with the key.
  *   - Each group has also an associated so-called insertion counter used for
  *     the following optimistic insertion algorithm:
  *     - The value of the insertion counter for the initial group in the probe
  *       sequence is locally recorded (let's call this value c0).
  *     - Lookup is as described above. If lookup finds no equivalent element,
  *       search for an available slot for insertion successively locks/unlocks
  *       each group in the probing sequence.
  *     - When an available slot is located, it is preemptively occupied (its
  *       reduced hash value is set) and the insertion counter is atomically
  *       incremented: if no other thread has incremented the counter during the
  *       whole operation (which is checked by comparing with c0), then we're
  *       good to go and complete the insertion, otherwise we roll back and
  *       start over.
  */
 
-template<typename,typename,typename,typename>
+template<typename,typename,typename,typename,typename>
 class table; /* concurrent/non-concurrent interop */
 
-template <typename TypePolicy,typename Hash,typename Pred,typename Allocator>
+template <typename TypePolicy,typename Hash,typename Pred,typename Allocator,typename Spin>
 using concurrent_table_core_impl=table_core<
   TypePolicy,group15<atomic_integral>,concurrent_table_arrays,
-  atomic_size_control,Hash,Pred,Allocator>;
+  atomic_size_control,Hash,Pred,Allocator,Spin>;
 
 #include <boost/unordered/detail/foa/ignore_wshadow.hpp>
 
 #if defined(BOOST_MSVC)
 #pragma warning(push)
 #pragma warning(disable:4714) /* marked as __forceinline not inlined */
 #endif
 
-template<typename TypePolicy,typename Hash,typename Pred,typename Allocator>
+template<typename TypePolicy,typename Hash,typename Pred,typename Allocator,typename Spin>
 class concurrent_table:
-  concurrent_table_core_impl<TypePolicy,Hash,Pred,Allocator>
+  concurrent_table_core_impl<TypePolicy,Hash,Pred,Allocator,Spin>
 {
-  using super=concurrent_table_core_impl<TypePolicy,Hash,Pred,Allocator>;
+  using super=concurrent_table_core_impl<TypePolicy,Hash,Pred,Allocator,Spin>;
   using type_policy=typename super::type_policy;
   using group_type=typename super::group_type;
   using super::N;
   using prober=typename super::prober;
   using arrays_type=typename super::arrays_type;
   using size_ctrl_type=typename super::size_ctrl_type;
-  using compatible_nonconcurrent_table=table<TypePolicy,Hash,Pred,Allocator>;
-  friend compatible_nonconcurrent_table;
+  template <typename Spin2>
+  using compatible_nonconcurrent_table=table<TypePolicy,Hash,Pred,Allocator,Spin2>;
+  friend compatible_nonconcurrent_table<std::true_type>;
+  friend compatible_nonconcurrent_table<std::false_type>;
+
 
 public:
   using key_type=typename super::key_type;
   using init_type=typename super::init_type;
   using value_type=typename super::value_type;
   using element_type=typename super::element_type;
   using hasher=typename super::hasher;
   using key_equal=typename super::key_equal;
   using allocator_type=typename super::allocator_type;
   using size_type=typename super::size_type;
   static constexpr std::size_t bulk_visit_size=16;
 
 #if defined(BOOST_UNORDERED_ENABLE_STATS)
   using stats=typename super::stats;
 #endif
 
 private:
   template<typename Value,typename T>
   using enable_if_is_value_type=typename std::enable_if<
     !std::is_same<init_type,value_type>::value&&
     std::is_same<Value,value_type>::value,
     T
   >::type;
 
 public:
   concurrent_table(
     std::size_t n=default_bucket_count,const Hash& h_=Hash(),
     const Pred& pred_=Pred(),const Allocator& al_=Allocator()):
     super{n,h_,pred_,al_}
     {}
 
   concurrent_table(const concurrent_table& x):
     concurrent_table(x,x.exclusive_access()){}
   concurrent_table(concurrent_table&& x):
     concurrent_table(std::move(x),x.exclusive_access()){}
   concurrent_table(const concurrent_table& x,const Allocator& al_):
     concurrent_table(x,al_,x.exclusive_access()){}
   concurrent_table(concurrent_table&& x,const Allocator& al_):
     concurrent_table(std::move(x),al_,x.exclusive_access()){}
 
-  template<typename ArraysType>
+  template<typename ArraysType, typename Spin2>
   concurrent_table(
-    compatible_nonconcurrent_table&& x,
+    compatible_nonconcurrent_table<Spin2>&& x,
     arrays_holder<ArraysType,Allocator>&& ah):
     super{
       std::move(x.h()),std::move(x.pred()),std::move(x.al()),
       [&x]{return arrays_type::new_group_access(
         x.al(),typename arrays_type::super{
           x.arrays.groups_size_index,x.arrays.groups_size_mask,
           to_pointer<typename arrays_type::group_type_pointer>(
             reinterpret_cast<group_type*>(x.arrays.groups())),
           x.arrays.elements_});},
       size_ctrl_type{x.size_ctrl.ml,x.size_ctrl.size}}
   {
     x.arrays=ah.release();
     x.size_ctrl.ml=x.initial_max_load();
     x.size_ctrl.size=0;
     BOOST_UNORDERED_SWAP_STATS(this->cstats,x.cstats);
   }
 
-  concurrent_table(compatible_nonconcurrent_table&& x):
+  template<typename Spin2>
+  concurrent_table(compatible_nonconcurrent_table<Spin2>&& x):
     concurrent_table(std::move(x),x.make_empty_arrays())
   {}
 
   ~concurrent_table()=default;
 
   concurrent_table& operator=(const concurrent_table& x)
   {
     auto lck=exclusive_access(*this,x);
     super::operator=(x);
     return *this;
   }
 
   concurrent_table& operator=(concurrent_table&& x)noexcept(
     noexcept(std::declval<super&>() = std::declval<super&&>()))
   {
     auto lck=exclusive_access(*this,x);
     super::operator=(std::move(x));
     return *this;
   }
 
@@ -979,61 +986,61 @@ public:
       x,[](const value_type&){return true;},std::forward<Extractor>(ext));
   }
 
   template<typename Key,typename F,typename Extractor>
   BOOST_FORCEINLINE void extract_if(const Key& x,F&& f,Extractor&& ext)
   {
     auto        lck=shared_access();
     auto        hash=this->hash_for(x);
     unprotected_internal_visit(
       group_exclusive{},x,this->position_for(hash),hash,
       [&,this](group_type* pg,unsigned int n,element_type* p)
       {
         if(f(cast_for(group_exclusive{},type_policy::value_from(*p)))){
           ext(std::move(*p),this->al());
           super::erase(pg,n,p);
         }
       });
   }
 
   // TODO: should we accept different allocator too?
-  template<typename Hash2,typename Pred2>
-  size_type merge(concurrent_table<TypePolicy,Hash2,Pred2,Allocator>& x)
+  template<typename Hash2,typename Pred2,typename Spin2>
+  size_type merge(concurrent_table<TypePolicy,Hash2,Pred2,Allocator,Spin2>& x)
   {
-    using merge_table_type=concurrent_table<TypePolicy,Hash2,Pred2,Allocator>;
+    using merge_table_type=concurrent_table<TypePolicy,Hash2,Pred2,Allocator,Spin2>;
     using super2=typename merge_table_type::super;
 
     // for clang
     boost::ignore_unused<super2>();
 
     auto      lck=exclusive_access(*this,x);
     size_type s=super::size();
     x.super2::for_all_elements( /* super2::for_all_elements -> unprotected */
       [&,this](group_type* pg,unsigned int n,element_type* p){
         typename merge_table_type::erase_on_exit e{x,pg,n,p};
         if(!unprotected_emplace(type_policy::move(*p)))e.rollback();
       });
     return size_type{super::size()-s};
   }
 
-  template<typename Hash2,typename Pred2>
-  void merge(concurrent_table<TypePolicy,Hash2,Pred2,Allocator>&& x){merge(x);}
+  template<typename Hash2,typename Pred2,typename Spin2>
+  void merge(concurrent_table<TypePolicy,Hash2,Pred2,Allocator,Spin2>&& x){merge(x);}
 
   hasher hash_function()const
   {
     auto lck=shared_access();
     return super::hash_function();
   }
 
   key_equal key_eq()const
   {
     auto lck=shared_access();
     return super::key_eq();
   }
 
   template<typename Key>
   BOOST_FORCEINLINE std::size_t count(Key&& x)const
   {
     return (std::size_t)contains(std::forward<Key>(x));
   }
 
   template<typename Key>
@@ -1084,85 +1091,85 @@ public:
 #endif
 
   template<typename Predicate>
   friend std::size_t erase_if(concurrent_table& x,Predicate&& pr)
   {
     return x.erase_if(std::forward<Predicate>(pr));
   }
 
   friend bool operator==(const concurrent_table& x,const concurrent_table& y)
   {
     auto lck=exclusive_access(x,y);
     return static_cast<const super&>(x)==static_cast<const super&>(y);
   }
 
   friend bool operator!=(const concurrent_table& x,const concurrent_table& y)
   {
     return !(x==y);
   }
 
 private:
-  template<typename,typename,typename,typename> friend class concurrent_table;
+  template<typename,typename,typename,typename,typename> friend class concurrent_table;
 
-  using mutex_type=rw_spinlock;
+  using mutex_type=std::conditional_t<Spin::value, rw_spinlock, boost::interprocess::interprocess_sharable_mutex>;
   using multimutex_type=multimutex<mutex_type,128>; // TODO: adapt 128 to the machine
   using shared_lock_guard=reentrancy_checked<shared_lock<mutex_type>>;
   using exclusive_lock_guard=reentrancy_checked<lock_guard<multimutex_type>>;
   using exclusive_bilock_guard=
     reentrancy_bichecked<scoped_bilock<multimutex_type>>;
-  using group_shared_lock_guard=typename group_access::shared_lock_guard;
-  using group_exclusive_lock_guard=typename group_access::exclusive_lock_guard;
-  using group_insert_counter_type=typename group_access::insert_counter_type;
+  using group_shared_lock_guard=typename group_access<Spin>::shared_lock_guard;
+  using group_exclusive_lock_guard=typename group_access<Spin>::exclusive_lock_guard;
+  using group_insert_counter_type=typename group_access<Spin>::insert_counter_type;
 
   concurrent_table(const concurrent_table& x,exclusive_lock_guard):
     super{x}{}
   concurrent_table(concurrent_table&& x,exclusive_lock_guard):
     super{std::move(x)}{}
   concurrent_table(
     const concurrent_table& x,const Allocator& al_,exclusive_lock_guard):
     super{x,al_}{}
   concurrent_table(
     concurrent_table&& x,const Allocator& al_,exclusive_lock_guard):
     super{std::move(x),al_}{}
 
   inline shared_lock_guard shared_access()const
   {
     thread_local auto id=(++thread_counter)%mutexes.size();
 
     return shared_lock_guard{this,mutexes[id]};
   }
 
   inline exclusive_lock_guard exclusive_access()const
   {
     return exclusive_lock_guard{this,mutexes};
   }
 
   static inline exclusive_bilock_guard exclusive_access(
     const concurrent_table& x,const concurrent_table& y)
   {
     return {&x,&y,x.mutexes,y.mutexes};
   }
 
   template<typename Hash2,typename Pred2>
   static inline exclusive_bilock_guard exclusive_access(
     const concurrent_table& x,
-    const concurrent_table<TypePolicy,Hash2,Pred2,Allocator>& y)
+    const concurrent_table<TypePolicy,Hash2,Pred2,Allocator,Spin>& y)
   {
     return {&x,&y,x.mutexes,y.mutexes};
   }
 
   /* Tag-dispatched shared/exclusive group access */
 
   using group_shared=std::false_type;
   using group_exclusive=std::true_type;
 
   inline group_shared_lock_guard access(group_shared,std::size_t pos)const
   {
     return this->arrays.group_accesses()[pos].shared_access();
   }
 
   inline group_exclusive_lock_guard access(
     group_exclusive,std::size_t pos)const
   {
     return this->arrays.group_accesses()[pos].exclusive_access();
   }
 
@@ -1959,35 +1966,35 @@ private:
       auto&                                k=key.get();
       auto&                                m=mapped.get();
       auto                                 hash=this->hash_for(k);
       auto                                 pos0=this->position_for(hash);
 
       if(this->find(k,pos0,hash))throw_exception(bad_archive_exception());
       auto loc=this->unchecked_emplace_at(pos0,hash,std::move(k),std::move(m));
       ar.reset_object_address(
         std::addressof(type_policy::value_from(*loc.p).first),
         std::addressof(k));
       ar.reset_object_address(
         std::addressof(type_policy::value_from(*loc.p).second),
         std::addressof(m));
     }
   }
 
   static std::atomic<std::size_t> thread_counter;
   mutable multimutex_type         mutexes;
 };
 
-template<typename T,typename H,typename P,typename A>
-std::atomic<std::size_t> concurrent_table<T,H,P,A>::thread_counter={};
+template<typename T,typename H,typename P,typename A,typename S>
+std::atomic<std::size_t> concurrent_table<T,H,P,A,S>::thread_counter={};
 
 #if defined(BOOST_MSVC)
 #pragma warning(pop) /* C4714 */
 #endif
 
 #include <boost/unordered/detail/foa/restore_wshadow.hpp>
 
 } /* namespace foa */
 } /* namespace detail */
 } /* namespace unordered */
 } /* namespace boost */
 
 #endif
diff --git a/include/boost/unordered/detail/foa/core.hpp b/include/boost/unordered/detail/foa/core.hpp
index 062b7112..d1696331 100644
--- a/include/boost/unordered/detail/foa/core.hpp
+++ b/include/boost/unordered/detail/foa/core.hpp
@@ -985,41 +985,41 @@ struct arrays_holder
 
   ~arrays_holder()
   {
     if(!released_){
       arrays_.delete_(typename Arrays::allocator_type(al_),arrays_);
     }
   }
 
   const Arrays& release()
   {
     released_=true;
     return arrays_;
   }
 
 private:
   Arrays    arrays_;
   Allocator al_;
   bool      released_=false;
 };
 
-template<typename Value,typename Group,typename SizePolicy,typename Allocator>
+template<typename Value,typename Group,typename SizePolicy,typename Allocator,typename Spin>
 struct table_arrays
 {
   using allocator_type=typename boost::allocator_rebind<Allocator,Value>::type;
 
   using value_type=Value;
   using group_type=Group;
   static constexpr auto N=group_type::N;
   using size_policy=SizePolicy;
   using value_type_pointer=
     typename boost::allocator_pointer<allocator_type>::type;
   using group_type_pointer=
     typename boost::pointer_traits<value_type_pointer>::template
       rebind<group_type>;
   using group_type_pointer_traits=boost::pointer_traits<group_type_pointer>;
 
   // For natvis purposes
   using char_pointer=
     typename boost::pointer_traits<value_type_pointer>::template
       rebind<unsigned char>;
 
@@ -1392,64 +1392,64 @@ using is_emplace_kv_able = std::integral_constant<bool,
  *     the element_type itself is moved.
  */
 
 #include <boost/unordered/detail/foa/ignore_wshadow.hpp>
 
 #if defined(BOOST_MSVC)
 #pragma warning(push)
 #pragma warning(disable:4714) /* marked as __forceinline not inlined */
 #endif
 
 #if BOOST_WORKAROUND(BOOST_MSVC,<=1900)
 /* VS2015 marks as unreachable generic catch clauses around non-throwing
  * code.
  */
 #pragma warning(push)
 #pragma warning(disable:4702)
 #endif
 
 template<
   typename TypePolicy,typename Group,template<typename...> class Arrays,
-  typename SizeControl,typename Hash,typename Pred,typename Allocator
+  typename SizeControl,typename Hash,typename Pred,typename Allocator,typename Spin
 >
 class 
 
 #if defined(_MSC_VER)&&_MSC_FULL_VER>=190023918
 __declspec(empty_bases) /* activate EBO with multiple inheritance */
 #endif
 
 table_core:empty_value<Hash,0>,empty_value<Pred,1>,empty_value<Allocator,2>
 {
 public:
   using type_policy=TypePolicy;
   using group_type=Group;
   static constexpr auto N=group_type::N;
   using size_policy=pow2_size_policy;
   using prober=pow2_quadratic_prober;
   using mix_policy=typename std::conditional<
     hash_is_avalanching<Hash>::value,
     no_mix,
     mulx_mix
   >::type;
   using alloc_traits=boost::allocator_traits<Allocator>;
   using element_type=typename type_policy::element_type;
-  using arrays_type=Arrays<element_type,group_type,size_policy,Allocator>;
+  using arrays_type=Arrays<element_type,group_type,size_policy,Allocator,Spin>;
   using size_ctrl_type=SizeControl;
   static constexpr auto uses_fancy_pointers=!std::is_same<
     typename alloc_traits::pointer,
     typename alloc_traits::value_type*
   >::value;
 
   using key_type=typename type_policy::key_type;
   using init_type=typename type_policy::init_type;
   using value_type=typename type_policy::value_type;
   using hasher=Hash;
   using key_equal=Pred;
   using allocator_type=Allocator;
   using pointer=value_type*;
   using const_pointer=const value_type*;
   using reference=value_type&;
   using const_reference=const value_type&;
   using size_type=std::size_t;
   using difference_type=std::ptrdiff_t;
   using locator=table_locator<group_type,element_type>;
   using arrays_holder_type=arrays_holder<arrays_type,Allocator>;
@@ -2065,41 +2065,41 @@ public:
         while(mask){
           auto n=unchecked_countr_zero(mask);
           if(!f(pg,n,p+n))return false;
           mask&=mask-1;
         }
       }
     }
     return true;
   }
 
   arrays_type              arrays;
   size_ctrl_type           size_ctrl;
 
 #if defined(BOOST_UNORDERED_ENABLE_STATS)
   mutable cumulative_stats cstats;
 #endif
 
 private:
   template<
     typename,typename,template<typename...> class,
-    typename,typename,typename,typename
+    typename,typename,typename,typename,typename
   >
   friend class table_core;
 
   using hash_base=empty_value<Hash,0>;
   using pred_base=empty_value<Pred,1>;
   using allocator_base=empty_value<Allocator,2>;
 
 #if defined(BOOST_GCC)
 #pragma GCC diagnostic push
 #pragma GCC diagnostic ignored "-Wmaybe-uninitialized"
 #endif
 
   /* used by allocator-extended move ctor */
 
   table_core(Hash&& h_,Pred&& pred_,const Allocator& al_):
     hash_base{empty_init,std::move(h_)},
     pred_base{empty_init,std::move(pred_)},
     allocator_base{empty_init,al_},arrays(new_arrays(0)),
     size_ctrl{initial_max_load(),0}
   {
diff --git a/include/boost/unordered/detail/foa/table.hpp b/include/boost/unordered/detail/foa/table.hpp
index 529a514c..9c759d69 100644
--- a/include/boost/unordered/detail/foa/table.hpp
+++ b/include/boost/unordered/detail/foa/table.hpp
@@ -39,41 +39,41 @@ struct plain_integral
   operator Integral()const{return n;}
   void operator=(Integral m){n=m;}
 
 #if BOOST_WORKAROUND(BOOST_GCC,>=50000 && BOOST_GCC<60000)
   void operator|=(Integral m){n=static_cast<Integral>(n|m);}
   void operator&=(Integral m){n=static_cast<Integral>(n&m);}
 #else
   void operator|=(Integral m){n|=m;}
   void operator&=(Integral m){n&=m;}
 #endif
 
   Integral n;
 };
 
 struct plain_size_control
 {
   std::size_t ml;
   std::size_t size;
 };
 
-template<typename,typename,typename,typename>
+template<typename,typename,typename,typename,typename>
 class table;
 
 /* table_iterator keeps two pointers:
  * 
  *   - A pointer p to the element slot.
  *   - A pointer pc to the n-th byte of the associated group metadata, where n
  *     is the position of the element in the group.
  *
  * A simpler solution would have been to keep a pointer p to the element, a
  * pointer pg to the group, and the position n, but that would increase
  * sizeof(table_iterator) by 4/8 bytes. In order to make this compact
  * representation feasible, it is required that group objects are aligned
  * to their size, so that we can recover pg and n as
  * 
  *   - n = pc%sizeof(group)
  *   - pg = pc-n
  * 
  * (for explanatory purposes pg and pc are treated above as if they were memory
  * addresses rather than pointers).
  * 
@@ -116,41 +116,41 @@ public:
     const_iterator_cast_tag, const table_iterator<TypePolicy,GroupPtr,true>& x):
     pc_{x.pc_},p_{x.p_}{}
 
   inline reference operator*()const noexcept
     {return type_policy::value_from(*p());}
   inline pointer operator->()const noexcept
     {return std::addressof(type_policy::value_from(*p()));}
   inline table_iterator& operator++()noexcept{increment();return *this;}
   inline table_iterator operator++(int)noexcept
     {auto x=*this;increment();return x;}
   friend inline bool operator==(
     const table_iterator& x,const table_iterator& y)
     {return x.p()==y.p();}
   friend inline bool operator!=(
     const table_iterator& x,const table_iterator& y)
     {return !(x==y);}
 
 private:
   template<typename,typename,bool> friend class table_iterator;
   template<typename> friend class table_erase_return_type;
-  template<typename,typename,typename,typename> friend class table;
+  template<typename,typename,typename,typename,typename> friend class table;
 
   table_iterator(group_type* pg,std::size_t n,const table_element_type* ptet):
     pc_{to_pointer<char_pointer>(
       reinterpret_cast<unsigned char*>(const_cast<group_type*>(pg))+n)},
     p_{to_pointer<table_element_pointer>(const_cast<table_element_type*>(ptet))}
   {}
 
   unsigned char* pc()const noexcept{return boost::to_address(pc_);}
   table_element_type* p()const noexcept{return boost::to_address(p_);}
 
   inline void increment()noexcept
   {
     BOOST_ASSERT(p()!=nullptr);
     increment(std::integral_constant<bool,regular_layout>{});
   }
 
   inline void increment(std::true_type /* regular layout */)noexcept
   {
     using diff_type=
       typename boost::pointer_traits<char_pointer>::difference_type;
@@ -251,106 +251,108 @@ class table_erase_return_type<table_iterator<TypePolicy,GroupPtr,Const>>
   using const_iterator=table_iterator<TypePolicy,GroupPtr,true>;
 
 public:
   /* can't delete it because VS in pre-C++17 mode needs to see it for RVO */
   table_erase_return_type(const table_erase_return_type&);
 
   operator iterator()const noexcept
   {
     auto it=pos;
     it.increment(); /* valid even if *it was erased */
     return iterator(const_iterator_cast_tag{},it);
   }
 
   template<
     bool dependent_value=false,
     typename std::enable_if<!Const||dependent_value>::type* =nullptr
   >
   operator const_iterator()const noexcept{return this->operator iterator();}
 
 private:
-  template<typename,typename,typename,typename> friend class table;
+  template<typename,typename,typename,typename,typename> friend class table;
 
   table_erase_return_type(const_iterator pos_):pos{pos_}{}
   table_erase_return_type& operator=(const table_erase_return_type&)=delete;
 
   const_iterator pos;
 };
 
 /* foa::table interface departs in a number of ways from that of C++ unordered
  * associative containers because it's not for end-user consumption
  * (boost::unordered_(flat|node)_(map|set) wrappers complete it as
  * appropriate).
  *
  * The table supports two main modes of operation: flat and node-based. In the
  * flat case, buckets directly store elements. For node-based, buckets store
  * pointers to individually heap-allocated elements.
  *
  * For both flat and node-based:
  *
  *   - begin() is not O(1).
  *   - No bucket API.
  *   - Load factor is fixed and can't be set by the user.
  * 
  * For flat only:
  *
  *   - value_type must be moveable.
  *   - Pointer stability is not kept under rehashing.
  *   - No extract API.
  *
  * try_emplace, erase and find support heterogeneous lookup by default,
  * that is, without checking for any ::is_transparent typedefs --the
  * checking is done by boost::unordered_(flat|node)_(map|set).
  */
 
-template<typename,typename,typename,typename>
+template<typename,typename,typename,typename,typename>
 class concurrent_table; /* concurrent/non-concurrent interop */
 
-template <typename TypePolicy,typename Hash,typename Pred,typename Allocator>
+template <typename TypePolicy,typename Hash,typename Pred,typename Allocator,typename Spin=std::true_type>
 using table_core_impl=
   table_core<TypePolicy,group15<plain_integral>,table_arrays,
-  plain_size_control,Hash,Pred,Allocator>;
+  plain_size_control,Hash,Pred,Allocator,Spin>;
 
 #include <boost/unordered/detail/foa/ignore_wshadow.hpp>
 
 #if defined(BOOST_MSVC)
 #pragma warning(push)
 #pragma warning(disable:4714) /* marked as __forceinline not inlined */
 #endif
 
-template<typename TypePolicy,typename Hash,typename Pred,typename Allocator>
-class table:table_core_impl<TypePolicy,Hash,Pred,Allocator>
+template<typename TypePolicy,typename Hash,typename Pred,typename Allocator,typename Spin=std::true_type>
+class table:table_core_impl<TypePolicy,Hash,Pred,Allocator,Spin>
 {
-  using super=table_core_impl<TypePolicy,Hash,Pred,Allocator>;
+  using super=table_core_impl<TypePolicy,Hash,Pred,Allocator,Spin>;
   using type_policy=typename super::type_policy;
   using group_type=typename super::group_type;
   using super::N;
   using prober=typename super::prober;
   using arrays_type=typename super::arrays_type;
   using size_ctrl_type=typename super::size_ctrl_type;
   using locator=typename super::locator;
+  template <typename Spin2>
   using compatible_concurrent_table=
-    concurrent_table<TypePolicy,Hash,Pred,Allocator>;
+    concurrent_table<TypePolicy,Hash,Pred,Allocator,Spin2>;
   using group_type_pointer=typename boost::pointer_traits<
     typename boost::allocator_pointer<Allocator>::type
   >::template rebind<group_type>;
-  friend compatible_concurrent_table;
+  friend compatible_concurrent_table<std::true_type>;
+  friend compatible_concurrent_table<std::false_type>;
 
 public:
   using key_type=typename super::key_type;
   using init_type=typename super::init_type;
   using value_type=typename super::value_type;
   using element_type=typename super::element_type;
 
 private:
   static constexpr bool has_mutable_iterator=
     !std::is_same<key_type,value_type>::value;
 public:
   using hasher=typename super::hasher;
   using key_equal=typename super::key_equal;
   using allocator_type=typename super::allocator_type;
   using pointer=typename super::pointer;
   using const_pointer=typename super::const_pointer;
   using reference=typename super::reference;
   using const_reference=typename super::const_reference;
   using size_type=typename super::size_type;
   using difference_type=typename super::difference_type;
@@ -358,41 +360,42 @@ public:
   using iterator=typename std::conditional<
     has_mutable_iterator,
     table_iterator<type_policy,group_type_pointer,false>,
     const_iterator>::type;
   using erase_return_type=table_erase_return_type<iterator>;
 
 #if defined(BOOST_UNORDERED_ENABLE_STATS)
   using stats=typename super::stats;
 #endif
 
   table(
     std::size_t n=default_bucket_count,const Hash& h_=Hash(),
     const Pred& pred_=Pred(),const Allocator& al_=Allocator()):
     super{n,h_,pred_,al_}
     {}
 
   table(const table& x)=default;
   table(table&& x)=default;
   table(const table& x,const Allocator& al_):super{x,al_}{}
   table(table&& x,const Allocator& al_):super{std::move(x),al_}{}
-  table(compatible_concurrent_table&& x):
+  template <typename Spin2>
+  table(compatible_concurrent_table<Spin2>&& x):
     table(std::move(x),x.exclusive_access()){}
   ~table()=default;
 
   table& operator=(const table& x)=default;
   table& operator=(table&& x)=default;
 
   using super::get_allocator;
 
   iterator begin()noexcept
   {
     iterator it{this->arrays.groups(),0,this->arrays.elements()};
     if(this->arrays.elements()&&
        !(this->arrays.groups()[0].match_occupied()&0x1))++it;
     return it;
   }
 
   const_iterator begin()const noexcept
                    {return const_cast<table*>(this)->begin();}
   iterator       end()noexcept{return {};}
   const_iterator end()const noexcept{return const_cast<table*>(this)->end();}
@@ -495,51 +498,51 @@ public:
     else return 0;
   }
 
   void swap(table& x)
     noexcept(noexcept(std::declval<super&>().swap(std::declval<super&>())))
   {
     super::swap(x);
   }
 
   using super::clear;
 
   element_type extract(const_iterator pos)
   {
     BOOST_ASSERT(pos!=end());
     erase_on_exit e{*this,pos};
     (void)e;
     return std::move(*pos.p());
   }
 
   // TODO: should we accept different allocator too?
-  template<typename Hash2,typename Pred2>
-  void merge(table<TypePolicy,Hash2,Pred2,Allocator>& x)
+  template<typename Hash2,typename Pred2,typename Spin2>
+  void merge(table<TypePolicy,Hash2,Pred2,Allocator,Spin2>& x)
   {
     x.for_all_elements([&,this](group_type* pg,unsigned int n,element_type* p){
       erase_on_exit e{x,{pg,n,p}};
       if(!emplace_impl(type_policy::move(*p)).second)e.rollback();
     });
   }
 
-  template<typename Hash2,typename Pred2>
-  void merge(table<TypePolicy,Hash2,Pred2,Allocator>&& x){merge(x);}
+  template<typename Hash2,typename Pred2,typename Spin2>
+  void merge(table<TypePolicy,Hash2,Pred2,Allocator,Spin2>&& x){merge(x);}
 
   using super::hash_function;
   using super::key_eq;
 
   template<typename Key>
   BOOST_FORCEINLINE iterator find(const Key& x)
   {
     return make_iterator(super::find(x));
   }
 
   template<typename Key>
   BOOST_FORCEINLINE const_iterator find(const Key& x)const
   {
     return const_cast<table*>(this)->find(x);
   }
 
   using super::capacity;
   using super::load_factor;
   using super::max_load_factor;
   using super::max_load;
@@ -561,60 +564,60 @@ public:
     >::type;
 
     std::size_t s=x.size();
     x.for_all_elements(
       [&](group_type* pg,unsigned int n,element_type* p){
         if(pr(const_cast<value_reference>(type_policy::value_from(*p)))){
           x.super::erase(pg,n,p);
         }
       });
     return std::size_t(s-x.size());
   }
 
   friend bool operator==(const table& x,const table& y)
   {
     return static_cast<const super&>(x)==static_cast<const super&>(y);
   }
 
   friend bool operator!=(const table& x,const table& y){return !(x==y);}
 
 private:
-  template<typename ArraysType>
-  table(compatible_concurrent_table&& x,arrays_holder<ArraysType,Allocator>&& ah):
+  template<typename ArraysType, typename Spin2>
+  table(compatible_concurrent_table<Spin2>&& x,arrays_holder<ArraysType,Allocator>&& ah):
     super{
       std::move(x.h()),std::move(x.pred()),std::move(x.al()),
       [&x]{return arrays_type{
         x.arrays.groups_size_index,x.arrays.groups_size_mask,
         to_pointer<group_type_pointer>(
           reinterpret_cast<group_type*>(x.arrays.groups())),
         x.arrays.elements_};},
       size_ctrl_type{x.size_ctrl.ml,x.size_ctrl.size}}
   {
-    compatible_concurrent_table::arrays_type::delete_group_access(x.al(),x.arrays);
+    compatible_concurrent_table<Spin2>::arrays_type::delete_group_access(x.al(),x.arrays);
     x.arrays=ah.release();
     x.size_ctrl.ml=x.initial_max_load();
     x.size_ctrl.size=0;
     BOOST_UNORDERED_SWAP_STATS(this->cstats,x.cstats);
   }
 
-  template<typename ExclusiveLockGuard>
-  table(compatible_concurrent_table&& x,ExclusiveLockGuard):
+  template<typename ExclusiveLockGuard, typename Spin2>
+  table(compatible_concurrent_table<Spin2>&& x,ExclusiveLockGuard):
     table(std::move(x),x.make_empty_arrays())
   {}
 
   struct erase_on_exit
   {
     erase_on_exit(table& x_,const_iterator it_):x(x_),it(it_){}
     ~erase_on_exit(){if(!rollback_)x.erase(it);}
 
     void rollback(){rollback_=true;}
 
     table&         x;
     const_iterator it;
     bool           rollback_=false;
   };
 
   static inline iterator make_iterator(const locator& l)noexcept
   {
     return {l.pg,l.n,l.p};
   }
 
diff --git a/include/boost/unordered/detail/implementation.hpp b/include/boost/unordered/detail/implementation.hpp
index d2c0cbd0..49d5d483 100644
--- a/include/boost/unordered/detail/implementation.hpp
+++ b/include/boost/unordered/detail/implementation.hpp
@@ -104,153 +104,153 @@ namespace boost {
       struct no_key
       {
         no_key() {}
         template <class T> no_key(T const&) {}
       };
 
       struct converting_key
       {
       };
 
       namespace func {
         template <class T> inline void ignore_unused_variable_warning(T const&)
         {
         }
       } // namespace func
 
       //////////////////////////////////////////////////////////////////////////
       // iterator SFINAE
 
       template <typename I>
-      struct is_forward : std::is_base_of<std::forward_iterator_tag,
-                            typename std::iterator_traits<I>::iterator_category>
+        struct is_forward : std::is_base_of<std::forward_iterator_tag,
+        typename std::iterator_traits<I>::iterator_category>
       {
       };
 
       template <typename I, typename ReturnType>
-      struct enable_if_forward
-          : std::enable_if<boost::unordered::detail::is_forward<I>::value,
-              ReturnType>
+        struct enable_if_forward
+        : std::enable_if<boost::unordered::detail::is_forward<I>::value,
+        ReturnType>
       {
       };
 
       template <typename I, typename ReturnType>
-      struct disable_if_forward
-          : std::enable_if<!boost::unordered::detail::is_forward<I>::value,
-              ReturnType>
+        struct disable_if_forward
+        : std::enable_if<!boost::unordered::detail::is_forward<I>::value,
+        ReturnType>
       {
       };
     } // namespace detail
   } // namespace unordered
 } // namespace boost
 
 namespace boost {
   namespace unordered {
     namespace detail {
       //////////////////////////////////////////////////////////////////////////
       // insert_size/initial_size
 
       template <class I>
-      inline typename boost::unordered::detail::enable_if_forward<I,
-        std::size_t>::type
-      insert_size(I i, I j)
-      {
-        return static_cast<std::size_t>(std::distance(i, j));
-      }
+        inline typename boost::unordered::detail::enable_if_forward<I,
+               std::size_t>::type
+                 insert_size(I i, I j)
+                 {
+                   return static_cast<std::size_t>(std::distance(i, j));
+                 }
 
       template <class I>
-      inline typename boost::unordered::detail::disable_if_forward<I,
-        std::size_t>::type
-      insert_size(I, I)
-      {
-        return 1;
-      }
+        inline typename boost::unordered::detail::disable_if_forward<I,
+               std::size_t>::type
+                 insert_size(I, I)
+                 {
+                   return 1;
+                 }
 
       template <class I>
-      inline std::size_t initial_size(I i, I j,
-        std::size_t num_buckets =
-          boost::unordered::detail::default_bucket_count)
-      {
-        return (std::max)(
-          boost::unordered::detail::insert_size(i, j), num_buckets);
-      }
+        inline std::size_t initial_size(I i, I j,
+                                        std::size_t num_buckets =
+                                        boost::unordered::detail::default_bucket_count)
+        {
+          return (std::max)(
+            boost::unordered::detail::insert_size(i, j), num_buckets);
+        }
 
       //////////////////////////////////////////////////////////////////////////
       // compressed
 
       template <typename T, int Index>
-      struct compressed_base : boost::empty_value<T>
+        struct compressed_base : boost::empty_value<T>
       {
         compressed_base(T const& x) : empty_value<T>(boost::empty_init_t(), x)
         {
         }
         compressed_base(T& x, move_tag)
-            : empty_value<T>(boost::empty_init_t(), std::move(x))
+          : empty_value<T>(boost::empty_init_t(), std::move(x))
         {
         }
 
         T& get() { return empty_value<T>::get(); }
         T const& get() const { return empty_value<T>::get(); }
       };
 
       template <typename T, int Index>
-      struct generate_base : boost::unordered::detail::compressed_base<T, Index>
+        struct generate_base : boost::unordered::detail::compressed_base<T, Index>
       {
         typedef compressed_base<T, Index> type;
 
         generate_base() : type() {}
       };
 
       template <typename T1, typename T2>
-      struct compressed
-          : private boost::unordered::detail::generate_base<T1, 1>::type,
-            private boost::unordered::detail::generate_base<T2, 2>::type
+        struct compressed
+        : private boost::unordered::detail::generate_base<T1, 1>::type,
+        private boost::unordered::detail::generate_base<T2, 2>::type
       {
         typedef typename generate_base<T1, 1>::type base1;
         typedef typename generate_base<T2, 2>::type base2;
 
         typedef T1 first_type;
         typedef T2 second_type;
 
         first_type& first() { return static_cast<base1*>(this)->get(); }
 
         first_type const& first() const
         {
           return static_cast<base1 const*>(this)->get();
         }
 
         second_type& second() { return static_cast<base2*>(this)->get(); }
 
         second_type const& second() const
         {
           return static_cast<base2 const*>(this)->get();
         }
 
         template <typename First, typename Second>
-        compressed(First const& x1, Second const& x2) : base1(x1), base2(x2)
+          compressed(First const& x1, Second const& x2) : base1(x1), base2(x2)
         {
         }
 
         compressed(compressed const& x) : base1(x.first()), base2(x.second()) {}
 
         compressed(compressed& x, move_tag m)
-            : base1(x.first(), m), base2(x.second(), m)
+          : base1(x.first(), m), base2(x.second(), m)
         {
         }
 
         void assign(compressed const& x)
         {
           first() = x.first();
           second() = x.second();
         }
 
         void move_assign(compressed& x)
         {
           first() = std::move(x.first());
           second() = std::move(x.second());
         }
 
         void swap(compressed& x)
         {
           boost::core::invoke_swap(first(), x.first());
           boost::core::invoke_swap(second(), x.second());
         }
@@ -265,42 +265,42 @@ namespace boost {
       // pair_traits
       //
       // Used to get the types from a pair without instantiating it.
 
       template <typename Pair> struct pair_traits
       {
         typedef typename Pair::first_type first_type;
         typedef typename Pair::second_type second_type;
       };
 
       template <typename T1, typename T2> struct pair_traits<std::pair<T1, T2> >
       {
         typedef T1 first_type;
         typedef T2 second_type;
       };
 
 #if defined(BOOST_MSVC)
 #pragma warning(push)
 #pragma warning(disable : 4512) // assignment operator could not be generated.
 #pragma warning(disable : 4345) // behavior change: an object of POD type
-// constructed with an initializer of the form ()
-// will be default-initialized.
+                                // constructed with an initializer of the form ()
+                                // will be default-initialized.
 #endif
 
       //////////////////////////////////////////////////////////////////////////
       // Bits and pieces for implementing traits
 
       template <typename T> typename std::add_lvalue_reference<T>::type make();
       struct choice2
       {
         typedef char (&type)[2];
       };
       struct choice1 : choice2
       {
         typedef char (&type)[1];
       };
       choice1 choose();
 
       typedef choice1::type yes_type;
       typedef choice2::type no_type;
 
       struct private_type
@@ -418,178 +418,178 @@ namespace boost {
         optional& operator=(optional<T>&& x)
         {
           destroy();
           if (x.has_value_) {
             move(x);
           }
           return *this;
         }
 
         ~optional() { destroy(); }
 
         bool has_value() const { return has_value_; }
         T& operator*() { return value_.value(); }
         T const& operator*() const { return value_.value(); }
         T* operator->() { return value_.value_ptr(); }
         T const* operator->() const { return value_.value_ptr(); }
 
         bool operator==(optional<T> const& x) const
         {
           return has_value_ ? x.has_value_ && value_.value() == x.value_.value()
-                            : !x.has_value_;
+            : !x.has_value_;
         }
 
         bool operator!=(optional<T> const& x) const { return !((*this) == x); }
 
         void swap(optional<T>& x)
         {
           if (has_value_ != x.has_value_) {
             if (has_value_) {
               x.move(*this);
             } else {
               move(x);
             }
           } else if (has_value_) {
             boost::core::invoke_swap(value_.value(), x.value_.value());
           }
         }
 
         friend void swap(optional<T>& x, optional<T>& y) { x.swap(y); }
       };
     } // namespace detail
   } // namespace unordered
 } // namespace boost
 
 ////////////////////////////////////////////////////////////////////////////////
 //
 // Allocator traits
 //
 
 namespace boost {
   namespace unordered {
     namespace detail {
 
       template <typename Alloc>
-      struct allocator_traits : boost::allocator_traits<Alloc>
+        struct allocator_traits : boost::allocator_traits<Alloc>
       {
       };
 
       template <typename Alloc, typename T>
-      struct rebind_wrap : boost::allocator_rebind<Alloc, T>
+        struct rebind_wrap : boost::allocator_rebind<Alloc, T>
       {
       };
     } // namespace detail
   } // namespace unordered
 } // namespace boost
 
 namespace boost {
   namespace unordered {
     namespace detail {
       namespace func {
         ////////////////////////////////////////////////////////////////////////
         // Trait to check for piecewise construction.
 
         template <typename A0> struct use_piecewise
         {
           static choice1::type test(choice1, std::piecewise_construct_t);
 
           static choice2::type test(choice2, ...);
 
           enum
           {
             value = sizeof(choice1::type) ==
-                    sizeof(test(choose(), boost::unordered::detail::make<A0>()))
+              sizeof(test(choose(), boost::unordered::detail::make<A0>()))
           };
         };
 
         ////////////////////////////////////////////////////////////////////////
         // Construct from variadic parameters
 
         template <typename Alloc, typename T, typename... Args>
-        inline void construct_from_args(
-          Alloc& alloc, T* address, Args&&... args)
-        {
-          boost::allocator_construct(
-            alloc, address, std::forward<Args>(args)...);
-        }
+          inline void construct_from_args(
+            Alloc& alloc, T* address, Args&&... args)
+          {
+            boost::allocator_construct(
+              alloc, address, std::forward<Args>(args)...);
+          }
 
         // For backwards compatibility, implement a special case for
         // piecewise_construct with boost::tuple
 
         template <typename A0> struct detect_std_tuple
         {
           template <class... Args>
-          static choice1::type test(choice1, std::tuple<Args...> const&);
+            static choice1::type test(choice1, std::tuple<Args...> const&);
 
           static choice2::type test(choice2, ...);
 
           enum
           {
             value = sizeof(choice1::type) ==
-                    sizeof(test(choose(), boost::unordered::detail::make<A0>()))
+              sizeof(test(choose(), boost::unordered::detail::make<A0>()))
           };
         };
 
         // Special case for piecewise_construct
 
         template <template <class...> class Tuple, class... Args,
-          std::size_t... Is, class... TupleArgs>
-        std::tuple<typename std::add_lvalue_reference<Args>::type...>
-        to_std_tuple_impl(boost::mp11::mp_list<Args...>,
-          Tuple<TupleArgs...>& tuple, boost::mp11::index_sequence<Is...>)
-        {
-          (void)tuple;
-          using std::get;
-          return std::tuple<typename std::add_lvalue_reference<Args>::type...>(
-            get<Is>(tuple)...);
-        }
+                 std::size_t... Is, class... TupleArgs>
+                   std::tuple<typename std::add_lvalue_reference<Args>::type...>
+                   to_std_tuple_impl(boost::mp11::mp_list<Args...>,
+                                     Tuple<TupleArgs...>& tuple, boost::mp11::index_sequence<Is...>)
+                   {
+                     (void)tuple;
+                     using std::get;
+                     return std::tuple<typename std::add_lvalue_reference<Args>::type...>(
+                       get<Is>(tuple)...);
+                   }
 
         template <class T>
-        using add_lvalue_reference_t =
+          using add_lvalue_reference_t =
           typename std::add_lvalue_reference<T>::type;
 
         template <template <class...> class Tuple, class... Args>
-        boost::mp11::mp_transform<add_lvalue_reference_t,
+          boost::mp11::mp_transform<add_lvalue_reference_t,
           boost::mp11::mp_remove<std::tuple<Args...>,
-            boost::tuples::null_type> >
-        to_std_tuple(Tuple<Args...>& tuple)
-        {
-          using list = boost::mp11::mp_remove<boost::mp11::mp_list<Args...>,
-            boost::tuples::null_type>;
-          using list_size = boost::mp11::mp_size<list>;
-          using index_seq = boost::mp11::make_index_sequence<list_size::value>;
-
-          return to_std_tuple_impl(list{}, tuple, index_seq{});
-        }
+          boost::tuples::null_type> >
+            to_std_tuple(Tuple<Args...>& tuple)
+            {
+              using list = boost::mp11::mp_remove<boost::mp11::mp_list<Args...>,
+              boost::tuples::null_type>;
+              using list_size = boost::mp11::mp_size<list>;
+              using index_seq = boost::mp11::make_index_sequence<list_size::value>;
+
+              return to_std_tuple_impl(list{}, tuple, index_seq{});
+            }
 
         template <typename Alloc, typename A, typename B, typename A0,
-          typename A1, typename A2>
-        inline typename std::enable_if<use_piecewise<A0>::value &&
-                                         !detect_std_tuple<A1>::value &&
-                                         !detect_std_tuple<A2>::value,
-          void>::type
-        construct_from_args(
-          Alloc& alloc, std::pair<A, B>* address, A0&&, A1&& a1, A2&& a2)
-        {
-          boost::allocator_construct(alloc, address, std::piecewise_construct,
-            to_std_tuple(a1), to_std_tuple(a2));
-        }
+                 typename A1, typename A2>
+                   inline typename std::enable_if<use_piecewise<A0>::value &&
+                   !detect_std_tuple<A1>::value &&
+                   !detect_std_tuple<A2>::value,
+                 void>::type
+                   construct_from_args(
+                     Alloc& alloc, std::pair<A, B>* address, A0&&, A1&& a1, A2&& a2)
+                   {
+                     boost::allocator_construct(alloc, address, std::piecewise_construct,
+                                                to_std_tuple(a1), to_std_tuple(a2));
+                   }
       } // namespace func
     } // namespace detail
   } // namespace unordered
 } // namespace boost
 
 namespace boost {
   namespace unordered {
     namespace detail {
 
       ///////////////////////////////////////////////////////////////////
       //
       // Node construction
 
       template <typename NodeAlloc> struct node_constructor
       {
         typedef NodeAlloc node_allocator;
         typedef boost::unordered::detail::allocator_traits<NodeAlloc>
           node_allocator_traits;
         typedef typename node_allocator_traits::value_type node;
         typedef typename node_allocator_traits::pointer node_pointer;
@@ -661,113 +661,113 @@ namespace boost {
       {
         if (node_) {
           value_allocator val_alloc(alloc_);
           boost::allocator_destroy(val_alloc, node_->value_ptr());
           boost::allocator_deallocate(alloc_, node_, 1);
         }
       }
     } // namespace detail
   } // namespace unordered
 } // namespace boost
 
 namespace boost {
   namespace unordered {
     namespace detail {
       namespace func {
 
         // Some nicer construct_node functions, might try to
         // improve implementation later.
 
         template <typename Alloc, typename... Args>
-        inline typename boost::allocator_pointer<Alloc>::type
-        construct_node_from_args(Alloc& alloc, Args&&... args)
-        {
-          typedef typename boost::allocator_value_type<Alloc>::type node;
-          typedef typename node::value_type value_type;
-          typedef typename boost::allocator_rebind<Alloc, value_type>::type
-            value_allocator;
+          inline typename boost::allocator_pointer<Alloc>::type
+          construct_node_from_args(Alloc& alloc, Args&&... args)
+          {
+            typedef typename boost::allocator_value_type<Alloc>::type node;
+            typedef typename node::value_type value_type;
+            typedef typename boost::allocator_rebind<Alloc, value_type>::type
+              value_allocator;
 
-          value_allocator val_alloc(alloc);
+            value_allocator val_alloc(alloc);
 
-          node_constructor<Alloc> a(alloc);
-          a.create_node();
-          construct_from_args(
-            val_alloc, a.node_->value_ptr(), std::forward<Args>(args)...);
-          return a.release();
-        }
+            node_constructor<Alloc> a(alloc);
+            a.create_node();
+            construct_from_args(
+              val_alloc, a.node_->value_ptr(), std::forward<Args>(args)...);
+            return a.release();
+          }
 
         template <typename Alloc, typename U>
-        inline typename boost::allocator_pointer<Alloc>::type construct_node(
-          Alloc& alloc, U&& x)
-        {
-          node_constructor<Alloc> a(alloc);
-          a.create_node();
+          inline typename boost::allocator_pointer<Alloc>::type construct_node(
+            Alloc& alloc, U&& x)
+          {
+            node_constructor<Alloc> a(alloc);
+            a.create_node();
 
-          typedef typename boost::allocator_value_type<Alloc>::type node;
-          typedef typename node::value_type value_type;
-          typedef typename boost::allocator_rebind<Alloc, value_type>::type
-            value_allocator;
+            typedef typename boost::allocator_value_type<Alloc>::type node;
+            typedef typename node::value_type value_type;
+            typedef typename boost::allocator_rebind<Alloc, value_type>::type
+              value_allocator;
 
-          value_allocator val_alloc(alloc);
+            value_allocator val_alloc(alloc);
 
-          boost::allocator_construct(
-            val_alloc, a.node_->value_ptr(), std::forward<U>(x));
-          return a.release();
-        }
+            boost::allocator_construct(
+              val_alloc, a.node_->value_ptr(), std::forward<U>(x));
+            return a.release();
+          }
 
         template <typename Alloc, typename Key>
-        inline typename boost::allocator_pointer<Alloc>::type
-        construct_node_pair(Alloc& alloc, Key&& k)
-        {
-          node_constructor<Alloc> a(alloc);
-          a.create_node();
+          inline typename boost::allocator_pointer<Alloc>::type
+          construct_node_pair(Alloc& alloc, Key&& k)
+          {
+            node_constructor<Alloc> a(alloc);
+            a.create_node();
 
-          typedef typename boost::allocator_value_type<Alloc>::type node;
-          typedef typename node::value_type value_type;
-          typedef typename boost::allocator_rebind<Alloc, value_type>::type
-            value_allocator;
+            typedef typename boost::allocator_value_type<Alloc>::type node;
+            typedef typename node::value_type value_type;
+            typedef typename boost::allocator_rebind<Alloc, value_type>::type
+              value_allocator;
 
-          value_allocator val_alloc(alloc);
+            value_allocator val_alloc(alloc);
 
-          boost::allocator_construct(val_alloc, a.node_->value_ptr(),
-            std::piecewise_construct,
-            std::forward_as_tuple(std::forward<Key>(k)),
-            std::forward_as_tuple());
-          return a.release();
-        }
+            boost::allocator_construct(val_alloc, a.node_->value_ptr(),
+                                       std::piecewise_construct,
+                                       std::forward_as_tuple(std::forward<Key>(k)),
+                                       std::forward_as_tuple());
+            return a.release();
+          }
 
         template <typename Alloc, typename Key, typename Mapped>
-        inline typename boost::allocator_pointer<Alloc>::type
-        construct_node_pair(Alloc& alloc, Key&& k, Mapped&& m)
-        {
-          node_constructor<Alloc> a(alloc);
-          a.create_node();
+          inline typename boost::allocator_pointer<Alloc>::type
+          construct_node_pair(Alloc& alloc, Key&& k, Mapped&& m)
+          {
+            node_constructor<Alloc> a(alloc);
+            a.create_node();
 
-          typedef typename boost::allocator_value_type<Alloc>::type node;
-          typedef typename node::value_type value_type;
-          typedef typename boost::allocator_rebind<Alloc, value_type>::type
-            value_allocator;
+            typedef typename boost::allocator_value_type<Alloc>::type node;
+            typedef typename node::value_type value_type;
+            typedef typename boost::allocator_rebind<Alloc, value_type>::type
+              value_allocator;
 
-          value_allocator val_alloc(alloc);
+            value_allocator val_alloc(alloc);
 
-          boost::allocator_construct(val_alloc, a.node_->value_ptr(),
-            std::piecewise_construct,
+            boost::allocator_construct(val_alloc, a.node_->value_ptr(),
+                                       std::piecewise_construct,
             std::forward_as_tuple(std::forward<Key>(k)),
             std::forward_as_tuple(std::forward<Mapped>(m)));
           return a.release();
         }
 
         template <typename Alloc, typename Key, typename... Args>
         inline typename boost::allocator_pointer<Alloc>::type
         construct_node_pair_from_args(Alloc& alloc, Key&& k, Args&&... args)
         {
           node_constructor<Alloc> a(alloc);
           a.create_node();
 
           typedef typename boost::allocator_value_type<Alloc>::type node;
           typedef typename node::value_type value_type;
           typedef typename boost::allocator_rebind<Alloc, value_type>::type
             value_allocator;
 
           value_allocator val_alloc(alloc);
 
           boost::allocator_construct(val_alloc, a.node_->value_ptr(),
diff --git a/include/boost/unordered/detail/type_traits.hpp b/include/boost/unordered/detail/type_traits.hpp
index f99f7f42..fe2ebe0e 100644
--- a/include/boost/unordered/detail/type_traits.hpp
+++ b/include/boost/unordered/detail/type_traits.hpp
@@ -162,40 +162,50 @@ namespace boost {
           !std::is_convertible<Key, const_iterator>::value;
       };
 
       template <class T>
       using remove_cvref_t =
         typename std::remove_cv<typename std::remove_reference<T>::type>::type;
 
       template <class T, class U>
       using is_similar = std::is_same<remove_cvref_t<T>, remove_cvref_t<U> >;
 
       template <class, class...> struct is_similar_to_any : std::false_type
       {
       };
       template <class T, class U, class... Us>
       struct is_similar_to_any<T, U, Us...>
           : std::conditional<is_similar<T, U>::value, is_similar<T, U>,
               is_similar_to_any<T, Us...> >::type
       {
       };
 
+      template <typename T>
+      struct is_true_or_false_type
+          : std::disjunction<std::is_same<T, std::true_type>,
+              std::is_same<T, std::false_type> >
+      {
+      };
+
+      template <typename T>
+      constexpr bool is_true_or_false_type_v = is_true_or_false_type<T>::value;
+
 #if BOOST_UNORDERED_TEMPLATE_DEDUCTION_GUIDES
       // https://eel.is/c++draft/container.requirements#container.alloc.reqmts-34
       // https://eel.is/c++draft/container.requirements#unord.req.general-243
 
       template <class InputIterator>
       constexpr bool const is_input_iterator_v =
         !std::is_integral<InputIterator>::value;
 
       template <class A, class = void> struct is_allocator
       {
         constexpr static bool const value = false;
       };
 
       template <class A>
       struct is_allocator<A,
         boost::unordered::detail::void_t<typename A::value_type,
           decltype(std::declval<A&>().allocate(std::size_t{}))> >
       {
         constexpr static bool const value = true;
       };
diff --git a/include/boost/unordered/unordered_flat_map.hpp b/include/boost/unordered/unordered_flat_map.hpp
index 6ad25d8e..c3642747 100644
--- a/include/boost/unordered/unordered_flat_map.hpp
+++ b/include/boost/unordered/unordered_flat_map.hpp
@@ -23,41 +23,41 @@
 #include <boost/container_hash/hash.hpp>
 
 #include <initializer_list>
 #include <iterator>
 #include <stdexcept>
 #include <type_traits>
 #include <utility>
 
 namespace boost {
   namespace unordered {
 
 #if defined(BOOST_MSVC)
 #pragma warning(push)
 #pragma warning(disable : 4714) /* marked as __forceinline not inlined */
 #endif
 
     template <class Key, class T, class Hash, class KeyEqual, class Allocator>
     class unordered_flat_map
     {
       template <class Key2, class T2, class Hash2, class Pred2,
-        class Allocator2>
+        class Allocator2, class Spin>
       friend class concurrent_flat_map;
 
       using map_types = detail::foa::flat_map_types<Key, T>;
 
       using table_type = detail::foa::table<map_types, Hash, KeyEqual,
         typename boost::allocator_rebind<Allocator,
           typename map_types::value_type>::type>;
 
       table_type table_;
 
       template <class K, class V, class H, class KE, class A>
       bool friend operator==(unordered_flat_map<K, V, H, KE, A> const& lhs,
         unordered_flat_map<K, V, H, KE, A> const& rhs);
 
       template <class K, class V, class H, class KE, class A, class Pred>
       typename unordered_flat_map<K, V, H, KE, A>::size_type friend erase_if(
         unordered_flat_map<K, V, H, KE, A>& set, Pred pred);
 
     public:
       using key_type = Key;
@@ -165,43 +165,43 @@ namespace boost {
       }
 
       unordered_flat_map(
         std::initializer_list<value_type> il, allocator_type const& a)
           : unordered_flat_map(il, size_type(0), hasher(), key_equal(), a)
       {
       }
 
       unordered_flat_map(std::initializer_list<value_type> init, size_type n,
         allocator_type const& a)
           : unordered_flat_map(init, n, hasher(), key_equal(), a)
       {
       }
 
       unordered_flat_map(std::initializer_list<value_type> init, size_type n,
         hasher const& h, allocator_type const& a)
           : unordered_flat_map(init, n, h, key_equal(), a)
       {
       }
 
-      template <bool avoid_explicit_instantiation = true>
+      template <typename Spin, bool avoid_explicit_instantiation = true>
       unordered_flat_map(
-        concurrent_flat_map<Key, T, Hash, KeyEqual, Allocator>&& other)
+        concurrent_flat_map<Key, T, Hash, KeyEqual, Allocator, Spin>&& other)
           : table_(std::move(other.table_))
       {
       }
 
       ~unordered_flat_map() = default;
 
       unordered_flat_map& operator=(unordered_flat_map const& other)
       {
         table_ = other.table_;
         return *this;
       }
 
       unordered_flat_map& operator=(unordered_flat_map&& other) noexcept(
         noexcept(std::declval<table_type&>() = std::declval<table_type&&>()))
       {
         table_ = std::move(other.table_);
         return *this;
       }
 
       unordered_flat_map& operator=(std::initializer_list<value_type> il)
diff --git a/include/boost/unordered/unordered_flat_set.hpp b/include/boost/unordered/unordered_flat_set.hpp
index 8e925931..ae234243 100644
--- a/include/boost/unordered/unordered_flat_set.hpp
+++ b/include/boost/unordered/unordered_flat_set.hpp
@@ -20,41 +20,41 @@
 
 #include <boost/core/allocator_access.hpp>
 #include <boost/container_hash/hash.hpp>
 
 #include <initializer_list>
 #include <iterator>
 #include <type_traits>
 #include <utility>
 
 namespace boost {
   namespace unordered {
 
 #if defined(BOOST_MSVC)
 #pragma warning(push)
 #pragma warning(disable : 4714) /* marked as __forceinline not inlined */
 #endif
 
     template <class Key, class Hash, class KeyEqual, class Allocator>
     class unordered_flat_set
     {
-      template <class Key2, class Hash2, class KeyEqual2, class Allocator2>
+      template <class Key2, class Hash2, class KeyEqual2, class Allocator2, class Spin>
       friend class concurrent_flat_set;
 
       using set_types = detail::foa::flat_set_types<Key>;
 
       using table_type = detail::foa::table<set_types, Hash, KeyEqual,
         typename boost::allocator_rebind<Allocator,
           typename set_types::value_type>::type>;
 
       table_type table_;
 
       template <class K, class H, class KE, class A>
       bool friend operator==(unordered_flat_set<K, H, KE, A> const& lhs,
         unordered_flat_set<K, H, KE, A> const& rhs);
 
       template <class K, class H, class KE, class A, class Pred>
       typename unordered_flat_set<K, H, KE, A>::size_type friend erase_if(
         unordered_flat_set<K, H, KE, A>& set, Pred pred);
 
     public:
       using key_type = Key;
@@ -161,43 +161,43 @@ namespace boost {
       }
 
       unordered_flat_set(
         std::initializer_list<value_type> il, allocator_type const& a)
           : unordered_flat_set(il, size_type(0), hasher(), key_equal(), a)
       {
       }
 
       unordered_flat_set(std::initializer_list<value_type> init, size_type n,
         allocator_type const& a)
           : unordered_flat_set(init, n, hasher(), key_equal(), a)
       {
       }
 
       unordered_flat_set(std::initializer_list<value_type> init, size_type n,
         hasher const& h, allocator_type const& a)
           : unordered_flat_set(init, n, h, key_equal(), a)
       {
       }
 
-      template <bool avoid_explicit_instantiation = true>
+      template <typename Spin, bool avoid_explicit_instantiation = true>
       unordered_flat_set(
-        concurrent_flat_set<Key, Hash, KeyEqual, Allocator>&& other)
+        concurrent_flat_set<Key, Hash, KeyEqual, Allocator, Spin>&& other)
           : table_(std::move(other.table_))
       {
       }
 
       ~unordered_flat_set() = default;
 
       unordered_flat_set& operator=(unordered_flat_set const& other)
       {
         table_ = other.table_;
         return *this;
       }
 
       unordered_flat_set& operator=(unordered_flat_set&& other) noexcept(
         noexcept(std::declval<table_type&>() = std::declval<table_type&&>()))
       {
         table_ = std::move(other.table_);
         return *this;
       }
 
       unordered_flat_set& operator=(std::initializer_list<value_type> il)
diff --git a/include/boost/unordered/unordered_node_map.hpp b/include/boost/unordered/unordered_node_map.hpp
index 6f644dc0..b355491b 100644
--- a/include/boost/unordered/unordered_node_map.hpp
+++ b/include/boost/unordered/unordered_node_map.hpp
@@ -24,41 +24,41 @@
 #include <boost/container_hash/hash.hpp>
 
 #include <initializer_list>
 #include <iterator>
 #include <stdexcept>
 #include <type_traits>
 #include <utility>
 
 namespace boost {
   namespace unordered {
 
 #if defined(BOOST_MSVC)
 #pragma warning(push)
 #pragma warning(disable : 4714) /* marked as __forceinline not inlined */
 #endif
 
     template <class Key, class T, class Hash, class KeyEqual, class Allocator>
     class unordered_node_map
     {
       template <class Key2, class T2, class Hash2, class Pred2,
-        class Allocator2>
+        class Allocator2, class Spin>
       friend class concurrent_node_map;
 
       using map_types = detail::foa::node_map_types<Key, T,
         typename boost::allocator_void_pointer<Allocator>::type>;
 
       using table_type = detail::foa::table<map_types, Hash, KeyEqual,
         typename boost::allocator_rebind<Allocator,
           std::pair<Key const, T> >::type>;
 
       table_type table_;
 
       template <class K, class V, class H, class KE, class A>
       bool friend operator==(unordered_node_map<K, V, H, KE, A> const& lhs,
         unordered_node_map<K, V, H, KE, A> const& rhs);
 
       template <class K, class V, class H, class KE, class A, class Pred>
       typename unordered_node_map<K, V, H, KE, A>::size_type friend erase_if(
         unordered_node_map<K, V, H, KE, A>& set, Pred pred);
 
     public:
@@ -172,43 +172,43 @@ namespace boost {
       }
 
       unordered_node_map(
         std::initializer_list<value_type> il, allocator_type const& a)
           : unordered_node_map(il, size_type(0), hasher(), key_equal(), a)
       {
       }
 
       unordered_node_map(std::initializer_list<value_type> init, size_type n,
         allocator_type const& a)
           : unordered_node_map(init, n, hasher(), key_equal(), a)
       {
       }
 
       unordered_node_map(std::initializer_list<value_type> init, size_type n,
         hasher const& h, allocator_type const& a)
           : unordered_node_map(init, n, h, key_equal(), a)
       {
       }
 
-      template <bool avoid_explicit_instantiation = true>
+      template <typename Spin, bool avoid_explicit_instantiation = true>
       unordered_node_map(
-        concurrent_node_map<Key, T, Hash, KeyEqual, Allocator>&& other)
+        concurrent_node_map<Key, T, Hash, KeyEqual, Allocator, Spin>&& other)
           : table_(std::move(other.table_))
       {
       }
 
       ~unordered_node_map() = default;
 
       unordered_node_map& operator=(unordered_node_map const& other)
       {
         table_ = other.table_;
         return *this;
       }
 
       unordered_node_map& operator=(unordered_node_map&& other) noexcept(
         noexcept(std::declval<table_type&>() = std::declval<table_type&&>()))
       {
         table_ = std::move(other.table_);
         return *this;
       }
 
       unordered_node_map& operator=(std::initializer_list<value_type> il)
diff --git a/include/boost/unordered/unordered_node_set.hpp b/include/boost/unordered/unordered_node_set.hpp
index 537f305e..5624c147 100644
--- a/include/boost/unordered/unordered_node_set.hpp
+++ b/include/boost/unordered/unordered_node_set.hpp
@@ -23,41 +23,41 @@
 #include <boost/core/allocator_access.hpp>
 #include <boost/container_hash/hash.hpp>
 #include <boost/throw_exception.hpp>
 
 #include <initializer_list>
 #include <iterator>
 #include <type_traits>
 #include <utility>
 
 namespace boost {
   namespace unordered {
 
 #if defined(BOOST_MSVC)
 #pragma warning(push)
 #pragma warning(disable : 4714) /* marked as __forceinline not inlined */
 #endif
 
     template <class Key, class Hash, class KeyEqual, class Allocator>
     class unordered_node_set
     {
-      template <class Key2, class Hash2, class Pred2, class Allocator2>
+      template <class Key2, class Hash2, class Pred2, class Allocator2, class Spin2>
       friend class concurrent_node_set;
 
       using set_types = detail::foa::node_set_types<Key,
         typename boost::allocator_void_pointer<Allocator>::type>;
 
       using table_type = detail::foa::table<set_types, Hash, KeyEqual,
         typename boost::allocator_rebind<Allocator,
           typename set_types::value_type>::type>;
 
       table_type table_;
 
       template <class K, class H, class KE, class A>
       bool friend operator==(unordered_node_set<K, H, KE, A> const& lhs,
         unordered_node_set<K, H, KE, A> const& rhs);
 
       template <class K, class H, class KE, class A, class Pred>
       typename unordered_node_set<K, H, KE, A>::size_type friend erase_if(
         unordered_node_set<K, H, KE, A>& set, Pred pred);
 
     public:
@@ -170,43 +170,43 @@ namespace boost {
       }
 
       unordered_node_set(
         std::initializer_list<value_type> il, allocator_type const& a)
           : unordered_node_set(il, size_type(0), hasher(), key_equal(), a)
       {
       }
 
       unordered_node_set(std::initializer_list<value_type> init, size_type n,
         allocator_type const& a)
           : unordered_node_set(init, n, hasher(), key_equal(), a)
       {
       }
 
       unordered_node_set(std::initializer_list<value_type> init, size_type n,
         hasher const& h, allocator_type const& a)
           : unordered_node_set(init, n, h, key_equal(), a)
       {
       }
 
-      template <bool avoid_explicit_instantiation = true>
+      template <typename Spin, bool avoid_explicit_instantiation = true>
       unordered_node_set(
-        concurrent_node_set<Key, Hash, KeyEqual, Allocator>&& other)
+        concurrent_node_set<Key, Hash, KeyEqual, Allocator, Spin>&& other)
           : table_(std::move(other.table_))
       {
       }
 
       ~unordered_node_set() = default;
 
       unordered_node_set& operator=(unordered_node_set const& other)
       {
         table_ = other.table_;
         return *this;
       }
 
       unordered_node_set& operator=(unordered_node_set&& other) noexcept(
         noexcept(std::declval<table_type&>() = std::declval<table_type&&>()))
       {
         table_ = std::move(other.table_);
         return *this;
       }
 
       unordered_node_set& operator=(std::initializer_list<value_type> il)
