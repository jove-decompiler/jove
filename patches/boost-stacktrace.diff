diff --git a/src/from_exception.cpp b/src/from_exception.cpp
index 366ba28..2e467f4 100644
--- a/src/from_exception.cpp
+++ b/src/from_exception.cpp
@@ -227,79 +227,88 @@ static bool is_libcpp_runtime() noexcept {
 #else
 
 static bool is_libcpp_runtime() noexcept { return false; }
 
 #endif
 
 static const char*& reference_to_empty_padding(void* ptr) noexcept {
   if (is_libcpp_runtime()) {
     // libc++-runtime
     BOOST_ASSERT_MSG(
       sizeof(void*) != 4,
       "32bit platforms are unsupported with libc++ runtime padding reusage. "
       "Please report this issue to the library maintainters."
     );
     return exception_begin_llvm_ptr(ptr)->reserve;
   }
 
   return exception_begin_gcc_ptr(ptr)->reserve;
 }
 
+extern "C"
+void* __real___cxa_allocate_exception(size_t thrown_size);
+
 extern "C" BOOST_SYMBOL_EXPORT
-void* __cxa_allocate_exception(size_t thrown_size) throw() {
+void* __wrap___cxa_allocate_exception(size_t thrown_size) throw() {
   static const auto orig_allocate_exception = []() {
+#if 0
     void* const ptr = ::dlsym(RTLD_NEXT, "__cxa_allocate_exception");
     BOOST_ASSERT_MSG(ptr, "Failed to find '__cxa_allocate_exception'");
     return reinterpret_cast<void*(*)(size_t)>(ptr);
+#else
+  return __real___cxa_allocate_exception;
+#endif
   }();
 
   if (!boost::stacktrace::impl::ref_capture_stacktraces_at_throw()) {
     return orig_allocate_exception(thrown_size);
   }
 
 #ifndef NDEBUG
   static thread_local std::size_t in_allocate_exception = 0;
   BOOST_ASSERT_MSG(in_allocate_exception < 10, "Suspicious recursion");
   ++in_allocate_exception;
   const decrement_on_destroy guard{in_allocate_exception};
 #endif
 
   static constexpr std::size_t kAlign = alignof(std::max_align_t);
   thrown_size = (thrown_size + kAlign - 1) & (~(kAlign - 1));
 
   void* const ptr = orig_allocate_exception(thrown_size + kStacktraceDumpSize);
   char* const dump_ptr = static_cast<char*>(ptr) + thrown_size;
 
   constexpr size_t kSkip = 1;
   boost::stacktrace::safe_dump_to(kSkip, dump_ptr, kStacktraceDumpSize);
 
 #if !BOOST_STACKTRACE_ALWAYS_STORE_IN_PADDING
   if (is_libcpp_runtime()) {
     const std::lock_guard<std::mutex> guard{g_mapping_mutex};
     g_exception_to_dump_mapping[ptr] = dump_ptr;
   } else
 #endif
   {
+#if 0
     BOOST_ASSERT_MSG(
       reference_to_empty_padding(ptr) == nullptr,
       "Not zeroed out, unsupported implementation"
     );
+#endif
     reference_to_empty_padding(ptr) = dump_ptr;
   }
 
   return ptr;
 }
 
 #if !BOOST_STACKTRACE_ALWAYS_STORE_IN_PADDING
 
 // __cxa_free_exception is not called in libc++ as the
 // __cxa_decrement_exception_refcount has an inlined call to
 // __cxa_free_exception. Overriding libc++ specific function
 extern "C" BOOST_SYMBOL_EXPORT
 void __cxa_decrement_exception_refcount(void *thrown_object) throw() {
   BOOST_ASSERT(is_libcpp_runtime());
   if (!thrown_object) {
     return;
   }
 
   static const auto orig_decrement_refcount = []() {
     void* const ptr = ::dlsym(RTLD_NEXT, "__cxa_decrement_exception_refcount");
